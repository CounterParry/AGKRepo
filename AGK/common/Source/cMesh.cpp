#include "agk.h"
#include <include/assimp/cimport.h>
#include <include/assimp/Importer.hpp>
#include <include/assimp/postprocess.h>
#include <include/assimp/scene.h>
#include <include/assimp/cfileio.h>

using namespace AGK;

AGKRenderState cMesh::g_shadowRenderState;

cMesh::cMesh( cObject3D *pParent ) : m_shaderConstants( 5 ), m_cOtherAttributeNames( 8 ), m_shaderImages(1), m_uvOffsetScales(1), m_shaderVarUVOffsetScales(0)
{
	m_pObject = pParent;
}

cMesh::cMesh( cObject3D *pParent, cMesh *pCopyFrom, int share ) : m_shaderConstants( 5 ), m_cOtherAttributeNames( 8 ), m_shaderImages(0), m_uvOffsetScales(0), m_shaderVarUVOffsetScales(0)
{
	m_BoundingBox.copy( &(pCopyFrom->m_BoundingBox) );
	//fRadius will be calculated by ProcessVertexData()

	m_iFlags = pCopyFrom->m_iFlags;

	m_sName.SetStr( pCopyFrom->m_sName );

	m_shaderImages.Clone( &pCopyFrom->m_shaderImages );

	m_pObject = pParent;
	SetShader( pCopyFrom->m_pOrigShader );

	if ( pCopyFrom->m_pShaderVarNormalScale )	m_pShaderVarNormalScale	 = pCopyFrom->m_pShaderVarNormalScale->Clone();
	if ( pCopyFrom->m_pShaderVarVSLightPos )	m_pShaderVarVSLightPos   = pCopyFrom->m_pShaderVarVSLightPos->Clone();
	if ( pCopyFrom->m_pShaderVarVSLightColor )	m_pShaderVarVSLightColor = pCopyFrom->m_pShaderVarVSLightColor->Clone();
	if ( pCopyFrom->m_pShaderVarPSLightPos )	m_pShaderVarPSLightPos   = pCopyFrom->m_pShaderVarPSLightPos->Clone();
	if ( pCopyFrom->m_pShaderVarPSLightColor )	m_pShaderVarPSLightColor = pCopyFrom->m_pShaderVarPSLightColor->Clone();

	m_iNumVSLights = pCopyFrom->m_iNumVSLights;
	m_iNumPSLights = pCopyFrom->m_iNumPSLights;
	for( uint32_t i = 0; i < m_iNumVSLights; i++ ) m_pVSLights[i] = pCopyFrom->m_pVSLights[i];
	for( uint32_t i = 0; i < m_iNumPSLights; i++ ) m_pPSLights[i] = pCopyFrom->m_pPSLights[i];

	if ( share == 1 && !pCopyFrom->m_pSharedVertices ) m_pSharedVertices = pCopyFrom;
	else m_pSharedVertices = pCopyFrom->m_pSharedVertices;

	// internal resources will be generated by ProcessVertexData()

	m_cOtherAttributeNames.Clone( &pCopyFrom->m_cOtherAttributeNames );

	m_vertexLayout.Clone( &pCopyFrom->m_vertexLayout );
	m_shadowVertexLayout.Clone( &pCopyFrom->m_shadowVertexLayout );

	m_fScaledBy = pCopyFrom->m_fScaledBy;

	m_uvOffsetScales.Expand( pCopyFrom->m_uvOffsetScales.GetHighestIndex() + 1 );
	for( int i = 0; i <= pCopyFrom->m_uvOffsetScales.GetHighestIndex(); i++ )
	{
		UVOffsetScale *pItem = pCopyFrom->m_uvOffsetScales.GetItem( i );
		if ( pItem )
		{
			UVOffsetScale *pNewItem = new UVOffsetScale();
			*pNewItem = *pItem;
			m_uvOffsetScales.SetItem( i, pNewItem );
		}
	}

	m_shaderVarUVOffsetScales.Expand( pCopyFrom->m_shaderVarUVOffsetScales.GetHighestIndex() + 1 );
	for( int i = 0; i <= pCopyFrom->m_shaderVarUVOffsetScales.GetHighestIndex(); i++ )
	{
		AGKShaderConstantValue *pItem = pCopyFrom->m_shaderVarUVOffsetScales.GetItem( i );
		if ( pItem )
		{
			pItem = pItem->Clone();
			m_shaderVarUVOffsetScales.SetItem( i, pItem );
		}
	}

	m_fNormalScaleU = pCopyFrom->m_fNormalScaleU;
	m_fNormalScaleV = pCopyFrom->m_fNormalScaleV;

	if ( share != 1 ) 
	{
		m_iNumRawVertices = pCopyFrom->m_iNumRawVertices;
		m_iNumAttribs = pCopyFrom->m_iNumAttribs;
		m_iPosAttrib = pCopyFrom->m_iPosAttrib;
		m_iNormAttrib = pCopyFrom->m_iNormAttrib;
		m_iUVAttrib = pCopyFrom->m_iUVAttrib;
		m_iUV1Attrib = pCopyFrom->m_iUV1Attrib;
		m_iTangentAttrib = pCopyFrom->m_iTangentAttrib;
		m_iBiNormAttrib = pCopyFrom->m_iBiNormAttrib;
		m_iColorAttrib = pCopyFrom->m_iColorAttrib;
		m_iBoneIndicesAttrib = pCopyFrom->m_iBoneIndicesAttrib;
		m_iBoneWeightsAttrib = pCopyFrom->m_iBoneWeightsAttrib;

		m_iNumRawIndices = pCopyFrom->m_iNumRawIndices;
	}

	m_iPrimitiveType = pCopyFrom->m_iPrimitiveType;
		
	if ( m_iNumRawIndices > 0 )
	{
		m_pRawIndices = new uint32_t[ m_iNumRawIndices ];
		memcpy( m_pRawIndices, pCopyFrom->m_pRawIndices, m_iNumRawIndices*sizeof(unsigned int) );
	}
	
	if ( m_iNumAttribs > 0 )
	{
		m_pVertexAttribs = new AGKVertexAttrib[ m_iNumAttribs ];
		for ( int i = 0; i < m_iNumAttribs; i++ )
		{
			m_pVertexAttribs[ i ].Copy( &pCopyFrom->m_pVertexAttribs[ i ], m_iNumRawVertices );
		}

		ProcessVertexData();
	}
}

cMesh::~cMesh()
{
	if ( m_pInternalPipeline ) agk::GetRenderer()->DeletePipeline( m_pInternalPipeline );
	if ( m_pInternalConstants ) agk::GetRenderer()->DeleteShaderConstants( m_pInternalConstants );
	if ( m_pInternalShadowPipeline ) agk::GetRenderer()->DeletePipeline( m_pInternalShadowPipeline );
	if ( m_pInternalShadowConstants ) agk::GetRenderer()->DeleteShaderConstants( m_pInternalShadowConstants );

	if ( m_pShaderVarNormalScale ) delete m_pShaderVarNormalScale;
	if ( m_pShaderVarVSLightPos ) delete m_pShaderVarVSLightPos;
	if ( m_pShaderVarVSLightColor ) delete m_pShaderVarVSLightColor;
	if ( m_pShaderVarPSLightPos ) delete m_pShaderVarPSLightPos;
	if ( m_pShaderVarPSLightColor ) delete m_pShaderVarPSLightColor;

	for( int i = 0; i <= m_uvOffsetScales.GetHighestIndex(); i++ )
	{
		UVOffsetScale *pItem = m_uvOffsetScales.GetItem( i );
		if ( pItem ) delete pItem;
	}

	for( int i = 0; i <= m_shaderVarUVOffsetScales.GetHighestIndex(); i++ )
	{
		AGKShaderConstantValue *pItem = m_shaderVarUVOffsetScales.GetItem( i );
		if ( pItem ) delete pItem;
	}

	DeleteInternalVertices();
	ClearAttribs();
}

void cMesh::ClearAttribs()
{
	if ( m_pVertexAttribs ) delete [] m_pVertexAttribs;
	m_cOtherAttributeNames.ClearAll();

	if ( m_pRawIndices ) delete [] m_pRawIndices;
	m_pRawIndices = 0;

	m_pVertexAttribs = 0;
	m_iPosAttrib = -1;
	m_iNormAttrib = -1;
	m_iUVAttrib = -1;
	m_iUV1Attrib = -1;
	m_iTangentAttrib = -1;
	m_iBiNormAttrib = -1;
	m_iColorAttrib = -1;
	m_iBoneIndicesAttrib = -1;
	m_iBoneWeightsAttrib = -1;
	m_iNumAttribs = 0;
	m_iFlags &= ~AGK_MESH_HAS_BONES;
}

void cMesh::ClearRawVertexData()
{
	for ( unsigned char i = 0; i < m_iNumAttribs; i++ ) m_pVertexAttribs[ i ].ClearData();

	if ( m_pRawIndices ) delete [] m_pRawIndices;
	m_pRawIndices = 0;
}

void cMesh::DeleteInternalVertices()
{
	// delete
	if ( m_pInternalVertices )
	{
		for ( uint32_t i = 0; i < m_iNumInternalVertices; i++ )
		{
			if ( m_pInternalVertices[i] ) agk::GetRenderer()->DeleteVertices( m_pInternalVertices[i] );
		}
		delete [] m_pInternalVertices;
		m_pInternalVertices = 0;
		m_iNumInternalVertices = 0;
	}
}

void cMesh::SetInternalVerticesCount( uint32_t num )
{
	if ( m_iNumInternalVertices > num )
	{
		// only delete entries above num
		for ( uint32_t i = num; i < m_iNumInternalVertices; i++ ) agk::GetRenderer()->DeleteVertices( m_pInternalVertices[i] );
		void **newArray = new void*[ num ];
		memcpy( newArray, m_pInternalVertices, num*sizeof(void*) );
		delete [] m_pInternalVertices;
		m_pInternalVertices = newArray;
		m_iNumInternalVertices = num;
	}
	else if ( m_iNumInternalVertices < num )
	{
		void **newArray = new void*[ num ];
		if ( m_pInternalVertices )
		{
			memcpy( newArray, m_pInternalVertices, m_iNumInternalVertices*sizeof(void*) );
			delete [] m_pInternalVertices;
		}
		for( uint32_t i = m_iNumInternalVertices; i < num; i++ ) newArray[ i ] = 0;
		m_pInternalVertices = newArray;
		m_iNumInternalVertices = num;
	}
}

// This function receives a single list of vertices and an optional list of indices.
// It must split the vertex list into batches of no more than 65536 vertices and 
// create new index lists (if any) to match.
// When this is finished the data passed in will have been copied and should be deleted
// vertexStride is the number of bytes per vertex, must be a multiple of 4.
void cMesh::CreateInternalVertices( float *pVertices, uint32_t numVertices, uint32_t vertexStride, uint32_t *pIndices, uint32_t numIndices )
{
	if ( vertexStride % 4 != 0 )
	{
		agk::Error( "vertex stride must be a multiple of 4" );
		return;
	}

	// triangle lists only
	if ( numIndices % 3 != 0 && m_iPrimitiveType == AGK_PRIMITIVE_TRIANGLES )
	{
		agk::Error( "number of indices must be a multiple of 3" );
		return;
	}

	if ( numVertices < 3 )
	{
		agk::Error( "vertex array must contain at least 3 vertices" );
		return;
	}
	
	if ( !pIndices ) numIndices = 0;
	
	// convert bytes to floats
	uint32_t vertexFloats = vertexStride / 4;

	// if no indices then nothing to do, no limit to num vertices
	if ( numIndices == 0 )
	{
		SetInternalVerticesCount( 1 );	
		agk::GetRenderer()->CreateVertices( vertexStride, &m_pInternalVertices[0] );
		agk::GetRenderer()->SetVertices( m_pInternalVertices[0], pVertices, numVertices );
	}
	else
	{
		// if there are less than 65536 vertices or device supports large buffers then don't split
		if ( numVertices <= 65536 )
		{
			unsigned short *pShortIndices = new unsigned short[ numIndices ];
			for( uint32_t i = 0; i < numIndices; i++ ) pShortIndices[ i ] = pIndices[ i ];

			SetInternalVerticesCount( 1 );

			agk::GetRenderer()->CreateVertices( vertexStride, &m_pInternalVertices[0] );
			agk::GetRenderer()->SetVertices( m_pInternalVertices[0], pVertices, numVertices );
			agk::GetRenderer()->SetIndices( m_pInternalVertices[0], pShortIndices, numIndices );

			delete [] pShortIndices;
		}
		else if ( agk::GetRenderer()->SupportsIntIndices() )
		{
			SetInternalVerticesCount( 1 );

			agk::GetRenderer()->CreateVertices( vertexStride, &m_pInternalVertices[0] );
			agk::GetRenderer()->SetVertices( m_pInternalVertices[0], pVertices, numVertices );
			agk::GetRenderer()->SetIndicesInt( m_pInternalVertices[0], pIndices, numIndices );
		}
		else
		{
			if ( m_iPrimitiveType != AGK_PRIMITIVE_TRIANGLES && m_iPrimitiveType != AGK_PRIMITIVE_TRIANGLE_STRIP )
			{
				agk::Error( "AGK needs to split the vertex buffer into chunks of 65536, but the the mesh uses an unsupported primitive type. The mesh will not draw on this device" );
				return;
			}

			// start with 1 array
			uint32_t iNumArrays = 1;
			uint32_t *iNumVertices = new uint32_t[ 1 ]; iNumVertices[ 0 ] = 0;
			uint32_t *iNumIndices = new uint32_t[ 1 ]; iNumIndices[ 0 ] = 0;
			uint32_t *iIndicesArraySize = new uint32_t[ 1 ]; iIndicesArraySize[ 0 ] = 16384;
			uint16_t **ppIndices = new uint16_t*[ 1 ];
			float **ppVertexData = new float*[ 1 ];

			ppIndices[ 0 ] = new unsigned short[ 16384 ];
			ppVertexData[ 0 ] = new float[ 65536*vertexFloats ];

			int *pReassignedArray = new int[ numVertices ];
			for ( uint32_t i = 0; i < numVertices; i++ ) pReassignedArray[ i ] = -1;
			int lastVertex = -1;
			int lastVertex2 = -1;

			for ( uint32_t i = 0; i < numIndices; i++ )
			{
				uint32_t v1 = pIndices[ i ];
				uint32_t v2 = 0;
				uint32_t v3 = 0;
					
				int add = 0;
				if ( pReassignedArray[ v1 ] == -1 ) add++;

				if ( m_iPrimitiveType == AGK_PRIMITIVE_TRIANGLES )
				{
					v2 = pIndices[ i+1 ];
					v3 = pIndices[ i+2 ];
					i += 2;

					if ( pReassignedArray[ v2 ] == -1 ) add++;
					if ( pReassignedArray[ v3 ] == -1 ) add++;
				}
				else if ( i % 2 == 0 )
				{
					// triangle strip
					// if index is even then we need to make sure there is enough room for 2 triangles to avoid next buffer having an inverted cull mode
					add++;
				}

				if ( add > 0 )
				{
					// add vertex to current vertex buffer
					if ( iNumVertices[ iNumArrays-1 ] + add > 65536 )
					{
						// vertex array full, start a new one
						iNumArrays++;
						uint32_t *newNumVertices = new uint32_t[ iNumArrays ]; newNumVertices[ iNumArrays-1 ] = 0;
						uint32_t *newNumIndices = new uint32_t[ iNumArrays ]; newNumIndices[ iNumArrays-1 ] = 0;
						uint32_t *newIndicesArraySize = new uint32_t[ iNumArrays ]; newIndicesArraySize[ iNumArrays-1 ] = 16384;
						unsigned short **newIndices = new unsigned short*[ iNumArrays ];
						float **newVBOVertexData = new float*[ iNumArrays ];
							
						newIndices[ iNumArrays-1 ] = new unsigned short[ 16384 ]; // increase this in chunks of 16384
						newVBOVertexData[ iNumArrays-1 ] = new float[ 65536*vertexFloats ]; // max 65536 vertices per buffer
							
						for ( uint32_t n = 0; n < iNumArrays-1; n++ )
						{
							newNumVertices[ n ] = iNumVertices[ n ];
							newNumIndices[ n ] = iNumIndices[ n ];
							newIndicesArraySize[ n ] = iIndicesArraySize[ n ];
							newIndices[ n ] = ppIndices[ n ];
							newVBOVertexData[ n ] = ppVertexData[ n ];
						}
							
						delete [] iNumVertices;
						delete [] iNumIndices;
						delete [] iIndicesArraySize;
						delete [] ppIndices;
						delete [] ppVertexData;
							
						iNumVertices = newNumVertices;
						iNumIndices = newNumIndices;
						iIndicesArraySize = newIndicesArraySize;
						ppIndices = newIndices;
						ppVertexData = newVBOVertexData;

						// no vertex currently assigned to the new array
						for ( uint32_t j = 0; j < numVertices; j++ ) pReassignedArray[ j ] = -1;
							
						if ( m_iPrimitiveType == AGK_PRIMITIVE_TRIANGLE_STRIP )
						{
							// assign the last two vertices to the new array, for triangle strip continuity
							iNumVertices[ iNumArrays-1 ] = 2;
							for ( uint32_t v = 0; v < vertexFloats; v++ ) 
							{
								ppVertexData[ iNumArrays-1 ][ v ] = pVertices[ lastVertex2*vertexFloats + v ];
								ppVertexData[ iNumArrays-1 ][ vertexFloats + v ] = pVertices[ lastVertex*vertexFloats + v ];
							}
							pReassignedArray[ lastVertex2 ] = 0;
							pReassignedArray[ lastVertex ] = 1;

							ppIndices[ iNumArrays-1 ][ 0 ] = 0;
							ppIndices[ iNumArrays-1 ][ 1 ] = 1;
							iNumIndices[ iNumArrays-1 ] = 2;
						}
					}

					// copy vertex into current buffer
					uint32_t indexV = iNumVertices[ iNumArrays-1 ];
					if ( pReassignedArray[ v1 ] == -1 )
					{
						for ( uint32_t v = 0; v < vertexFloats; v++ ) ppVertexData[ iNumArrays-1 ][ indexV*vertexFloats + v ] = pVertices[ v1*vertexFloats + v ];
						pReassignedArray[ v1 ] = indexV;
						indexV++;
					}

					if ( m_iPrimitiveType == AGK_PRIMITIVE_TRIANGLES )
					{
						if ( pReassignedArray[ v2 ] == -1 )
						{
							for ( uint32_t v = 0; v < vertexFloats; v++ ) ppVertexData[ iNumArrays-1 ][ indexV*vertexFloats + v ] = pVertices[ v2*vertexFloats + v ];
							pReassignedArray[ v2 ] = indexV;
							indexV++;
						}

						if ( pReassignedArray[ v3 ] == -1 )
						{
							for ( uint32_t v = 0; v < vertexFloats; v++ ) ppVertexData[ iNumArrays-1 ][ indexV*vertexFloats + v ] = pVertices[ v3*vertexFloats + v ];
							pReassignedArray[ v3 ] = indexV;
							indexV++;
						}
					}

					iNumVertices[ iNumArrays-1 ] = indexV;
				}

				lastVertex2 = lastVertex;
				lastVertex = v1;

				add = 1;
				if ( m_iPrimitiveType == AGK_PRIMITIVE_TRIANGLES ) add = 3;
				if ( iNumIndices[ iNumArrays-1 ] + add > iIndicesArraySize[ iNumArrays-1 ] )
				{
					// increase the size of the indices array
					unsigned short *newArray = new unsigned short[ iIndicesArraySize[ iNumArrays-1 ] + 16384 ];
					for ( uint32_t n = 0; n < iIndicesArraySize[ iNumArrays-1 ]; n++ ) newArray[ n ] = ppIndices[ iNumArrays-1 ][ n ];
					delete [] ppIndices[ iNumArrays-1 ];
					ppIndices[ iNumArrays-1 ] = newArray;
					iIndicesArraySize[ iNumArrays-1 ] += 16384;
				}

				uint32_t index2 = iNumIndices[ iNumArrays-1 ];
				ppIndices[ iNumArrays-1 ][ index2++ ] = pReassignedArray[ v1 ];
				if ( m_iPrimitiveType == AGK_PRIMITIVE_TRIANGLES )
				{
					ppIndices[ iNumArrays-1 ][ index2++ ] = pReassignedArray[ v2 ];
					ppIndices[ iNumArrays-1 ][ index2++ ] = pReassignedArray[ v3 ];
				}
				iNumIndices[ iNumArrays-1 ] = index2;
			}

			delete [] iIndicesArraySize;
			delete [] pReassignedArray;

			// create internal resources
			SetInternalVerticesCount( iNumArrays );
			for ( uint32_t i = 0; i < iNumArrays; i++ ) 
			{
				agk::GetRenderer()->CreateVertices( vertexStride, &m_pInternalVertices[i] );
				agk::GetRenderer()->SetVertices( m_pInternalVertices[i], ppVertexData[i], iNumVertices[i] );
				agk::GetRenderer()->SetIndices( m_pInternalVertices[i], ppIndices[i], iNumIndices[i] );

				delete [] ppVertexData[ i ];
				delete [] ppIndices[ i ];
			}
			
			delete [] iNumVertices;
			delete [] iNumIndices;
			delete [] ppIndices;
			delete [] ppVertexData;
		}
	}
}

void cMesh::ProcessVertexData()
{
	uint32_t stride = 0; // in floats
	for ( int i = 0; i < m_iNumAttribs; i++ ) 
	{
		stride += m_pVertexAttribs[ i ].m_iComponents;
	}

	float minX=1000000000, minY=1000000000, minZ=1000000000;
	float maxX=-1000000000, maxY=-1000000000, maxZ=-1000000000;
	m_fRadius = 0;

	float* pData = new float[ m_iNumRawVertices*stride ];
	float* pVertexDataF = 0;
	unsigned char* pVertexDataUB = 0;
	for ( uint32_t i = 0; i < m_iNumRawVertices; i++ )
	{
		uint32_t offset = 0;
		for ( int a = 0; a < m_iNumAttribs; a++ ) 
		{
			m_pVertexAttribs[ a ].m_iOffset = offset*4;
			uint32_t stride2 = m_pVertexAttribs[ a ].m_iComponents;
			if ( m_pVertexAttribs[ a ].m_iType == 0 ) 
			{
				pVertexDataF = (float*) (m_pVertexAttribs[ a ].m_pData);
				for ( uint32_t c = 0; c < stride2; c++ ) 
				{
					pData[ i*stride + (offset++) ] = pVertexDataF[ i*stride2 + c ];
				}

				// calculate bounding box
				if ( a == m_iPosAttrib )
				{
					float x = pVertexDataF[ i*stride2 + 0 ];
					float y = pVertexDataF[ i*stride2 + 1 ];
					float z = pVertexDataF[ i*stride2 + 2 ];

					if ( x < minX ) minX = x;
					if ( x > maxX ) maxX = x;
					
					if ( y < minY ) minY = y;
					if ( y > maxY ) maxY = y;

					if ( z < minZ ) minZ = z;
					if ( z > maxZ ) maxZ = z;

					float length = x*x + y*y + z*z;
					if ( length > m_fRadius ) m_fRadius = length;
				}
			}
			else if ( m_pVertexAttribs[ a ].m_iType == 1 ) 
			{
				pVertexDataUB = (unsigned char*) (m_pVertexAttribs[ a ].m_pData);
				if ( m_pVertexAttribs[ a ].m_iNormalize )
				{
					for ( uint32_t c = 0; c < stride2; c++ ) 
					{
						pData[ i*stride + (offset++) ] = pVertexDataUB[ i*stride2 + c ] / 255.0f;
					}
				}
				else
				{
					for ( uint32_t c = 0; c < stride2; c++ ) 
					{
						pData[ i*stride + (offset++) ] = pVertexDataUB[ i*stride2 + c ];
					}
				}				
			}
		}
	}

	m_vertexLayout.m_iVertexSize = stride*4;
	m_shadowVertexLayout.m_iVertexSize = stride*4;

	m_BoundingBox.set( minX, minY, minZ, maxX, maxY, maxZ );
	m_fRadius = agk::Sqrt( m_fRadius );

	CreateInternalVertices( pData, m_iNumRawVertices, stride*4, m_pRawIndices, m_iNumRawIndices );
	delete [] pData;
}

bool cMesh::HasValidBones() const 
{ 
	return HasBones() && (m_pObject != 0) && (m_pObject->GetSkeleton() != 0); 
}

bool cMesh::HasNormals() const
{ 
	if ( m_pSharedVertices ) return m_pSharedVertices->m_iNormAttrib >= 0; 
	else return m_iNormAttrib >= 0; 
}

bool cMesh::HasTangents() const
{ 
	if ( m_pSharedVertices ) return m_pSharedVertices->m_iTangentAttrib >= 0; 
	else return m_iTangentAttrib >= 0; 
}

bool cMesh::HasBiNormals() const
{ 
	if ( m_pSharedVertices ) return m_pSharedVertices->m_iBiNormAttrib >= 0; 
	else return m_iBiNormAttrib >= 0; 
}

bool cMesh::HasVertColors() const
{ 
	if ( m_pSharedVertices ) return m_pSharedVertices->m_iColorAttrib >= 0; 
	else return m_iColorAttrib >= 0; 
}

bool cMesh::HasUVs() const
{ 
	if ( m_pSharedVertices ) return m_pSharedVertices->m_iUVAttrib >= 0; 
	else return m_iUVAttrib >= 0; 
}

bool cMesh::HasUV1s() const 
{ 
	if ( m_pSharedVertices ) return m_pSharedVertices->m_iUV1Attrib >= 0; 
	else return m_iUV1Attrib >= 0; 
}

bool cMesh::HasUVStage( int stage ) const
{
	if ( stage == 0 && HasUVs() ) return true;
	if ( stage == 1 && HasUV1s() ) return true;
	return false;
}

int cMesh::WantsShadows() const 
{ 
	if ( m_pObject->GetLightMode() == 0 ) return 0;
	if ( m_pObject->DoesReceiveShadows() == 0 ) return 0;

	return 1;
}

uint32_t cMesh::GetInScreen() 
{ 
	if ( !m_pObject ) return 0;

	cCamera *pCamera = agk::GetCurrentCamera();
	if ( !pCamera ) return 0;

	if ( HasValidBones() ) 
	{
		if ( !m_pObject->GetSkeleton() ) return 1; // if the mesh has bones but the object doesn't then assume it is visible

		AGKVector normal[6];
		AGKVector origin[6];
		for ( int i = 0; i < 6; i++ )
		{
			float dist;
			pCamera->GetFrustumPlane( i, normal[i], dist );
			origin[i] = normal[i];
			origin[i].Mult( -dist );
		}

		for ( int b = 0; b < m_pObject->GetSkeleton()->GetBoneCount(); b++ )
		{
			Bone3D *pBone = m_pObject->GetSkeleton()->GetBone(b);
			AGKQuaternion q = pBone->rotFinal();
			q.Invert();

			int inside = 1;
			for ( int i = 0; i < 6; i++ )
			{
				AGKVector n2 = q * normal[i];
				n2 = n2 * pBone->scaleFinal();

				AGKVector origin2 = origin[i] - pBone->posFinal();
				origin2 = q * origin2;
				origin2 = origin2 / pBone->scaleFinal();

				float dist = -origin2.Dot( n2 );

				if ( !pBone->m_BoundingBox.inFrustumPlane( &n2, dist ) )
				{
					inside = 0;
					break;
				}
			}

			if ( inside == 1 )
			{
				return 1;
			}
		}
	}
	else
	{
		// not boned
		AGKVector n;
		float d;
		int inside = 1;
		for ( int i = 0; i < 6; i++ )
		{
			pCamera->GetFrustumPlane( i, n, d );

			AGKVector origin = n;
			origin.Mult( -d );

			AGKQuaternion q = m_pObject->rotFinal();
			q.Invert();
			n = q * n;
			n = n * m_pObject->scaleFinal();

			origin = origin - m_pObject->posFinal();
			origin = q * origin;
			origin = origin / m_pObject->scaleFinal();

			d = -origin.Dot( n );

			if ( !InFrustumPlane( &n, d ) ) 
			{
				inside = 0;
				break;
			}
		}

		if ( inside == 1 )
		{
			return 1;
		}
	}
	
	return 0;
}

uint32_t cMesh::GetInShadowFrustum() 
{ 
	if ( !m_pObject ) return 0;
	if ( m_iNumRawVertices < 20 ) return 1; // probably quicker to draw it even if it isn't visible?

	AGKMatrix4 shadowMat; shadowMat.Set( AGKShader::g_varShadowProj.GetValues() );

	float zMin = -1; float zMax = 1;
	if ( agk::GetRenderer()->IsClipSpaceZeroOne() ) zMin = 0;
	if ( agk::GetRenderer()->SupportsDepthClamp() ) 
	{
		if ( agk::GetRenderer()->IsInvertedDepth() ) zMax = 1e30f;
		else zMin = -1e30f;
	}

	if ( HasValidBones() ) 
	{
		if ( !m_pObject->GetSkeleton() ) return 1; // if the mesh has bones but the object doesn't then assume it is visible

		for ( int b = 0; b < m_pObject->GetSkeleton()->GetBoneCount(); b++ )
		{
			Bone3D *pBone = m_pObject->GetSkeleton()->GetBone(b);
			AGKMatrix4 boneMat;
			boneMat.MakeWorld( pBone->rotFinal(), pBone->posFinal(), pBone->scaleFinal() );
			boneMat.Mult( shadowMat );
			
			if ( pBone->m_BoundingBox.inFrustum( &boneMat, zMin, zMax ) ) return 1;
		}
	}
	else
	{
		// not boned
		AGKMatrix4 objMat;
		objMat.MakeWorld( m_pObject->rotFinal(), m_pObject->posFinal(), m_pObject->scaleFinal() );
		objMat.Mult( shadowMat );

		if ( m_BoundingBox.inFrustum( &objMat, zMin, zMax ) ) return 1;
	}

	return 0;
}

void cMesh::CreateBox( float width, float height, float length )
{
	ClearAttribs();
	m_fScaledBy = 1;
	m_iFlags |= AGK_MESH_VISIBLE | AGK_MESH_COLLISION;

	m_iNumAttribs = 3;
	m_pVertexAttribs = new AGKVertexAttrib[ m_iNumAttribs ];

	m_iPosAttrib = 0;
	m_iNormAttrib = 1;
	m_iUVAttrib = 2;
	AGKVertexAttrib *pAttribPos = &m_pVertexAttribs[ m_iPosAttrib ];
	AGKVertexAttrib *pAttribNorm = &m_pVertexAttribs[ m_iNormAttrib ];
	AGKVertexAttrib *pAttribTex = &m_pVertexAttribs[ m_iUVAttrib ];
	
	pAttribPos->m_iComponents = 3;
	pAttribPos->m_iType = 0;
	pAttribPos->m_szName = new char[ 9 ]; strcpy( pAttribPos->m_szName, "position" );
		
	pAttribNorm->m_iComponents = 3;
	pAttribNorm->m_iType = 0;
	pAttribNorm->m_szName = new char[ 7 ]; strcpy( pAttribNorm->m_szName, "normal" );

	pAttribTex->m_iComponents = 2;
	pAttribTex->m_iType = 0;
	pAttribTex->m_szName = new char[ 3 ]; strcpy( pAttribTex->m_szName, "uv" );

	float *pRawVertices = new float[ 24 * 3 ];	pAttribPos->m_pData = (void*) pRawVertices;
	float *pRawNormals = new float[ 24 * 3 ];	pAttribNorm->m_pData = (void*) pRawNormals;
	float *pRawUV = new float[ 24 * 2 ];		pAttribTex->m_pData = (void*) pRawUV;
	m_pRawIndices = new uint32_t[ 36 ];

	m_iNumRawVertices = 24;
	m_iNumRawIndices = 36;

	cVertex *pVertices = (cVertex*) pRawVertices;

	width /= 2;
	height /= 2;
	length /= 2;

	int vertexIndex = 0;
	for ( int i = 0; i < 6; i++ )
	{
		m_pRawIndices[ i*6 ] = vertexIndex;
		m_pRawIndices[ i*6 + 1 ] = ++vertexIndex;
		m_pRawIndices[ i*6 + 2 ] = ++vertexIndex;
		m_pRawIndices[ i*6 + 3 ] = vertexIndex;
		m_pRawIndices[ i*6 + 4 ] = vertexIndex-1;
		m_pRawIndices[ i*6 + 5 ] = ++vertexIndex;
		vertexIndex++;
	}

	// Face 1
	pVertices[ 0 ].x = -width;
	pVertices[ 0 ].y = height;
	pVertices[ 0 ].z = -length;

	pVertices[ 1 ].x = -width;
	pVertices[ 1 ].y = -height;
	pVertices[ 1 ].z = -length;

	pVertices[ 2 ].x = width;
	pVertices[ 2 ].y = height;
	pVertices[ 2 ].z = -length;

	pVertices[ 3 ].x = width;
	pVertices[ 3 ].y = -height;
	pVertices[ 3 ].z = -length;

	// Face 2
	pVertices[ 4 ].x = width;
	pVertices[ 4 ].y = height;
	pVertices[ 4 ].z = -length;

	pVertices[ 5 ].x = width;
	pVertices[ 5 ].y = -height;
	pVertices[ 5 ].z = -length;

	pVertices[ 6 ].x = width;
	pVertices[ 6 ].y = height;
	pVertices[ 6 ].z = length;

	pVertices[ 7 ].x = width;
	pVertices[ 7 ].y = -height;
	pVertices[ 7 ].z = length;

	// Face 3
	pVertices[ 8 ].x = -width;
	pVertices[ 8 ].y = height;
	pVertices[ 8 ].z = length;

	pVertices[ 9 ].x = -width;
	pVertices[ 9 ].y = height;
	pVertices[ 9 ].z = -length;

	pVertices[ 10 ].x = width;
	pVertices[ 10 ].y = height;
	pVertices[ 10 ].z = length;

	pVertices[ 11 ].x = width;
	pVertices[ 11 ].y = height;
	pVertices[ 11 ].z = -length;

	// Faces 4-5
	for ( int i = 0; i < 8; i++ )
	{
		pVertices[ i+12 ].x = -pVertices[ i ].x;
		pVertices[ i+12 ].y = pVertices[ i ].y;
		pVertices[ i+12 ].z = -pVertices[ i ].z;
	}

	// Face 6
	for ( int i = 8; i < 12; i++ )
	{
		pVertices[ i+12 ].x = pVertices[ i ].x;
		pVertices[ i+12 ].y = -pVertices[ i ].y;
		pVertices[ i+12 ].z = -pVertices[ i ].z;
	}

	// Normal 1
	for ( int i = 0; i < 4; i++ )
	{
		pRawNormals[ i*3 ] = 0;
		pRawNormals[ i*3 + 1 ] = 0;
		pRawNormals[ i*3 + 2 ] = -1;
	}

	// Normal 2
	for ( int i = 4; i < 8; i++ )
	{
		pRawNormals[ i*3 ] = 1;
		pRawNormals[ i*3 + 1 ] = 0;
		pRawNormals[ i*3 + 2 ] = 0;
	}

	// Normal 3
	for ( int i = 8; i < 12; i++ )
	{
		pRawNormals[ i*3 ] = 0;
		pRawNormals[ i*3 + 1 ] = 1;
		pRawNormals[ i*3 + 2 ] = 0;
	}

	// Normals 4-6
	for ( int i = 12; i < 24; i++ )
	{
		pRawNormals[ i*3 ] = -pRawNormals[ (i-12)*3 ];
		pRawNormals[ i*3 + 1 ] = -pRawNormals[ (i-12)*3 + 1 ];
		pRawNormals[ i*3 + 2 ] = -pRawNormals[ (i-12)*3 + 2 ];
	}

	// UVs 1-6
	for ( int i = 0; i < 6; i++ )
	{
		pRawUV[ i*8 + 0 ] = 0.0f;
		pRawUV[ i*8 + 1 ] = 0.0f;

		pRawUV[ i*8 + 2 ] = 0.0f;
		pRawUV[ i*8 + 3 ] = 1.0f;

		pRawUV[ i*8 + 4 ] = 1.0f;
		pRawUV[ i*8 + 5 ] = 0.0f;

		pRawUV[ i*8 + 6 ] = 1.0f;
		pRawUV[ i*8 + 7 ] = 1.0f;
	}
	
	ProcessVertexData();
}

// indexed sphere
void cMesh::CreateSphere( float diameter, int rows, int columns )
{
	if ( rows < 2 ) rows = 2;
	if ( columns < 3 ) columns = 3;

	float radius = diameter / 2.0f;

	ClearAttribs();
	m_fScaledBy = 1;
	m_iFlags |= AGK_MESH_VISIBLE | AGK_MESH_COLLISION;

	m_iNumAttribs = 3;
	m_pVertexAttribs = new AGKVertexAttrib[ m_iNumAttribs ];
	
	m_iPosAttrib = 0;
	m_iNormAttrib = 1;
	m_iUVAttrib = 2;
	AGKVertexAttrib *pAttribPos = &m_pVertexAttribs[ m_iPosAttrib ];
	AGKVertexAttrib *pAttribNorm = &m_pVertexAttribs[ m_iNormAttrib ];
	AGKVertexAttrib *pAttribTex = &m_pVertexAttribs[ m_iUVAttrib ];

	pAttribPos->m_iComponents = 3;
	pAttribPos->m_iType = 0;
	pAttribPos->m_szName = new char[ 9 ]; strcpy( pAttribPos->m_szName, "position" );
		
	pAttribNorm->m_iComponents = 3;
	pAttribNorm->m_iType = 0;
	pAttribNorm->m_szName = new char[ 7 ]; strcpy( pAttribNorm->m_szName, "normal" );

	pAttribTex->m_iComponents = 2;
	pAttribTex->m_iType = 0;
	pAttribTex->m_szName = new char[ 3 ]; strcpy( pAttribTex->m_szName, "uv" );

	int faces = (rows-1) * columns * 2;
	m_iNumRawVertices = (rows+1) * (columns+1); 
	m_iNumRawIndices = faces*3;

	float* pRawVertices = new float[ m_iNumRawVertices * 3 ];	pAttribPos->m_pData = (void*) pRawVertices;
	float* pRawNormals = new float[ m_iNumRawVertices * 3 ];		pAttribNorm->m_pData = (void*) pRawNormals;
	float* pRawUV = new float[ m_iNumRawVertices * 2 ];			pAttribTex->m_pData = (void*) pRawUV;
	m_pRawIndices = new uint32_t[ m_iNumRawIndices ];

	cVertex *pVertices = (cVertex*) pRawVertices;
//	cVertex *pNormals = (cVertex*) pRawNormals;
	
	float fSegY = PI / rows;
	float fSegX = 2*PI / columns;

	float fSegU = 1.0f / columns;
	float fSegV = 1.0f / rows;

	// vertices
	uint32_t count = 0;
	for ( int j = 0; j <= rows; j++ )
	{
		float fSY = agk::SinRad( fSegY*j );
		float fCY = agk::CosRad( fSegY*j );

		for ( int i = 0; i <= columns; i++ )
		{
			pVertices[ count ].x = agk::SinRad( -fSegX*i ) * fSY * radius;
			pVertices[ count ].y = fCY * radius;
			pVertices[ count ].z = agk::CosRad( -fSegX*i ) * fSY * radius;
			if ( j == 0 || j == rows ) pRawUV[ count*2 ] = fSegU*i + fSegU/2.0f;
			else pRawUV[ count*2 ] = fSegU*i;
			pRawUV[ count*2 + 1 ] = fSegV*j;
			count++;
		}
	}

	// normals
	for ( uint32_t i = 0 ; i < m_iNumRawVertices*3; i++ )
	{
		pRawNormals[ i ] = pRawVertices[ i ] / radius;
	}

	// indices
	uint32_t countI = 0;
	// top row
	for ( int i = 0; i < columns; i++ )
	{
		int next = i+1;

		m_pRawIndices[ countI*3 + 0 ] = i;
		m_pRawIndices[ countI*3 + 1 ] = columns+1 + i;
		m_pRawIndices[ countI*3 + 2 ] = columns+1 + next;
		countI++;
	}

	// middle rows
	for ( int j = 1; j < rows-1; j++ )
	{
		for ( int i = 0; i < columns; i++ )
		{
			int next = i+1;

			m_pRawIndices[ countI*3 + 0 ] = (columns+1)*j + i;
			m_pRawIndices[ countI*3 + 1 ] = (columns+1)*(j+1) + i;
			m_pRawIndices[ countI*3 + 2 ] = (columns+1)*j + next;
			countI++;

			m_pRawIndices[ countI*3 + 0 ] = (columns+1)*j + next;
			m_pRawIndices[ countI*3 + 1 ] = (columns+1)*(j+1) + i;
			m_pRawIndices[ countI*3 + 2 ] = (columns+1)*(j+1) + next;
			countI++;
		}
	}

	// bottom row
	for ( int i = 0; i < columns; i++ )
	{
		int next = i+1;

		m_pRawIndices[ countI*3 + 0 ] = (columns+1)*(rows-1) + i;
		m_pRawIndices[ countI*3 + 1 ] = (columns+1)*rows + i;
		m_pRawIndices[ countI*3 + 2 ] = (columns+1)*(rows-1) + next;
		countI++;
	}
	
	ProcessVertexData();
}

// perspective adjusted UV sphere
/*
void cMesh::CreateSphere2( float diameter, int rows, int columns )
{
	if ( rows < 2 ) rows = 2;
	if ( columns < 3 ) columns = 3;
	//if ( diameter < 0 ) diameter = 0;

	float radius = diameter / 2.0f;

	int faces = (rows-1) * columns * 2;
	m_iNumVertices = faces * 3; // could use indices and shared vertices to save space here
	m_iNumIndices = 0;
	
	if ( m_pVertices ) delete [] m_pVertices;
	if ( m_pNormals ) delete [] m_pNormals;
	if ( m_pUV ) delete [] m_pUV;
	if ( m_pIndices ) delete [] m_pIndices;

	m_pVertices = new float[ m_iNumVertices * 3 ];
	m_pNormals = new float[ m_iNumVertices * 3 ];
	m_pUV = new float[ m_iNumVertices * 3 ];
	m_pIndices = 0;

	cVertex *pVertices = (cVertex*) m_pVertices;
	cVertex *pNormals = (cVertex*) m_pNormals;
	
	float fSegY = PI / rows;
	float fSegX = 2*PI / columns;

	float fSegU = 1.0f / columns;
	float fSegV = 1.0f / rows;

	uint32_t count = 0;
	float fSY = agk::SinRad( fSegY );
	float fCY = agk::CosRad( fSegY );

	// top row, one polygon per segment
	for ( int i = 0; i < columns; i++ )
	{
		int next = i+1;
		if ( next >= columns ) next = 0;

		pVertices[ count ].x = 0;
		pVertices[ count ].y = radius;
		pVertices[ count ].z = 0;
		m_pUV[ count*3 ] = fSegU*i + fSegU/2.0f;
		m_pUV[ count*3 + 1 ] = 0;
		m_pUV[ count*3 + 2 ] = 1;
		count++;

		pVertices[ count ].x = agk::SinRad( -fSegX*i ) * fSY * radius;
		pVertices[ count ].y = fCY * radius;
		pVertices[ count ].z = agk::CosRad( -fSegX*i ) * fSY * radius;
		m_pUV[ count*3 ] = fSegU*i;
		m_pUV[ count*3 + 1 ] = fSegV;
		m_pUV[ count*3 + 2 ] = 1;
		count++;

		pVertices[ count ].x = agk::SinRad( -fSegX*next ) * fSY * radius;
		pVertices[ count ].y = fCY * radius;
		pVertices[ count ].z = agk::CosRad( -fSegX*next ) * fSY * radius;
		m_pUV[ count*3 ] = fSegU*(i+1);
		m_pUV[ count*3 + 1 ] = fSegV;
		m_pUV[ count*3 + 2 ] = 1;
		count++;
	}

	// middle rows, teo polygons per segment
	for ( int j = 1; j < rows-1; j++ )
	{
		fSY = agk::SinRad( fSegY*j );
		fCY = agk::CosRad( fSegY*j );

		float fSY2 = agk::SinRad( fSegY*(j+1) );
		float fCY2 = agk::CosRad( fSegY*(j+1) );

		for ( int i = 0; i < columns; i++ )
		{
			int next = i+1;
			if ( next >= columns ) next = 0;

			float x = fSY * radius * (agk::SinRad( -fSegX*i ) - agk::SinRad( -fSegX*next ));
			float z = fSY * radius * (agk::CosRad( -fSegX*i ) - agk::CosRad( -fSegX*next ));
			float distTop = agk::Sqrt(x*x + z*z);

			x = fSY2 * radius * (agk::SinRad( -fSegX*i ) - agk::SinRad( -fSegX*next ));
			z = fSY2 * radius * (agk::CosRad( -fSegX*i ) - agk::CosRad( -fSegX*next ));
			float distBottom = agk::Sqrt(x*x + z*z);

			float ratioTop = distTop/distBottom + 1;
			float ratioBottom = distBottom/distTop + 1;

			// polygon 1
			pVertices[ count ].x = agk::SinRad( -fSegX*i ) * fSY * radius;
			pVertices[ count ].y = fCY * radius;
			pVertices[ count ].z = agk::CosRad( -fSegX*i ) * fSY * radius;
			m_pUV[ count*3 ] = fSegU*i * ratioTop;
			m_pUV[ count*3 + 1 ] = fSegV*j * ratioTop;
			m_pUV[ count*3 + 2 ] = ratioTop;
			count++;

			pVertices[ count ].x = agk::SinRad( -fSegX*i ) * fSY2 * radius;
			pVertices[ count ].y = fCY2 * radius;
			pVertices[ count ].z = agk::CosRad( -fSegX*i ) * fSY2 * radius;
			m_pUV[ count*3 ] = fSegU*i * ratioBottom;
			m_pUV[ count*3 + 1 ] = fSegV*(j+1) * ratioBottom;
			m_pUV[ count*3 + 2 ] = ratioBottom;
			count++;

			pVertices[ count ].x = agk::SinRad( -fSegX*next ) * fSY * radius;
			pVertices[ count ].y = fCY * radius;
			pVertices[ count ].z = agk::CosRad( -fSegX*next ) * fSY * radius;
			m_pUV[ count*3 ] = fSegU*(i+1) * ratioTop;
			m_pUV[ count*3 + 1 ] = fSegV*j * ratioTop;
			m_pUV[ count*3 + 2 ] = ratioTop;
			count++;

			// polygon 2
			pVertices[ count ].x = agk::SinRad( -fSegX*next ) * fSY * radius;
			pVertices[ count ].y = fCY * radius;
			pVertices[ count ].z = agk::CosRad( -fSegX*next ) * fSY * radius;
			m_pUV[ count*3 ] = fSegU*(i+1) * ratioTop;
			m_pUV[ count*3 + 1 ] = fSegV*j * ratioTop;
			m_pUV[ count*3 + 2 ] = ratioTop;
			count++;

			pVertices[ count ].x = agk::SinRad( -fSegX*i ) * fSY2 * radius;
			pVertices[ count ].y = fCY2 * radius;
			pVertices[ count ].z = agk::CosRad( -fSegX*i ) * fSY2 * radius;
			m_pUV[ count*3 ] = fSegU*i * ratioBottom;
			m_pUV[ count*3 + 1 ] = fSegV*(j+1) * ratioBottom;
			m_pUV[ count*3 + 2 ] = ratioBottom;
			count++;

			pVertices[ count ].x = agk::SinRad( -fSegX*next ) * fSY2 * radius;
			pVertices[ count ].y = fCY2 * radius;
			pVertices[ count ].z = agk::CosRad( -fSegX*next ) * fSY2 * radius;
			m_pUV[ count*3 ] = fSegU*(i+1) * ratioBottom;
			m_pUV[ count*3 + 1 ] = fSegV*(j+1) * ratioBottom;
			m_pUV[ count*3 + 2 ] = ratioBottom;
			count++;
		}
	}

	fSY = agk::SinRad( PI-fSegY );
	fCY = agk::CosRad( PI-fSegY );

	// bottom row, one polygon per segment
	for ( int i = 0; i < columns; i++ )
	{
		int next = i+1;
		if ( next >= columns ) next = 0;

		pVertices[ count ].x = agk::SinRad( -fSegX*i ) * fSY * radius;
		pVertices[ count ].y = fCY * radius;
		pVertices[ count ].z = agk::CosRad( -fSegX*i ) * fSY * radius;
		m_pUV[ count*3 ] = fSegU*i;
		m_pUV[ count*3 + 1 ] = 1-fSegV;
		m_pUV[ count*3 + 2 ] = 1;
		count++;

		pVertices[ count ].x = 0;
		pVertices[ count ].y = -radius;
		pVertices[ count ].z = 0;
		m_pUV[ count*3 ] = fSegU*i + fSegU/2.0f;
		m_pUV[ count*3 + 1 ] = 1;
		m_pUV[ count*3 + 2 ] = 1;
		count++;

		pVertices[ count ].x = agk::SinRad( -fSegX*next ) * fSY * radius;
		pVertices[ count ].y = fCY * radius;
		pVertices[ count ].z = agk::CosRad( -fSegX*next ) * fSY * radius;
		m_pUV[ count*3 ] = fSegU*(i+1);
		m_pUV[ count*3 + 1 ] = 1-fSegV;
		m_pUV[ count*3 + 2 ] = 1;
		count++;		
	}

	for ( uint32_t i = 0 ; i < m_iNumVertices*3; i++ )
	{
		m_pNormals[ i ] = m_pVertices[ i ] / radius;
	}

	PlatformGenBuffers();
}
*/

void cMesh::CreateCone( float height, float diameter, int segments )
{
	if ( segments < 3 ) segments = 3;
	if ( diameter < 0 ) diameter = -diameter;

	float radius = diameter / 2.0f;

	ClearAttribs();

	m_fScaledBy = 1;
	m_iFlags |= AGK_MESH_VISIBLE | AGK_MESH_COLLISION;

	m_iNumAttribs = 3;
	m_pVertexAttribs = new AGKVertexAttrib[ m_iNumAttribs ];
	
	m_iPosAttrib = 0;
	m_iNormAttrib = 1;
	m_iUVAttrib = 2;
	AGKVertexAttrib *pAttribPos = &m_pVertexAttribs[ m_iPosAttrib ];
	AGKVertexAttrib *pAttribNorm = &m_pVertexAttribs[ m_iNormAttrib ];
	AGKVertexAttrib *pAttribTex = &m_pVertexAttribs[ m_iUVAttrib ];

	pAttribPos->m_iComponents = 3;
	pAttribPos->m_iType = 0;
	pAttribPos->m_szName = new char[ 9 ]; strcpy( pAttribPos->m_szName, "position" );
		
	pAttribNorm->m_iComponents = 3;
	pAttribNorm->m_iType = 0;
	pAttribNorm->m_szName = new char[ 7 ]; strcpy( pAttribNorm->m_szName, "normal" );

	pAttribTex->m_iComponents = 2;
	pAttribTex->m_iType = 0;
	pAttribTex->m_szName = new char[ 3 ]; strcpy( pAttribTex->m_szName, "uv" );

	int faces = segments*2;
	m_iNumRawVertices = faces * 3; 
	m_iNumRawIndices = 0;

	float* pRawVertices = new float[ m_iNumRawVertices * 3 ];	pAttribPos->m_pData = (void*) pRawVertices;
	float* pRawNormals = new float[ m_iNumRawVertices * 3 ];		pAttribNorm->m_pData = (void*) pRawNormals;
	float* pRawUV = new float[ m_iNumRawVertices * 2 ];			pAttribTex->m_pData = (void*) pRawUV;
	
	cVertex *pVertices = (cVertex*) pRawVertices;
	cVertex *pNormals = (cVertex*) pRawNormals;
	
	float fSegX = 2*PI / segments;
//	float fSegU = 1.0f / segments;

	uint32_t count = 0;
	
	// cone part
	for ( int i = 0; i < segments; i++ )
	{
		int next = i+1;
		if ( next >= segments ) next = 0;

		pVertices[ count ].x = 0;
		pVertices[ count ].y = height/2.0f;
		pVertices[ count ].z = 0;
		pNormals[ count ].x = 0;
		pNormals[ count ].y = 1;
		pNormals[ count ].z = 0;
		pRawUV[ count*2 ] = 0.5f;
		pRawUV[ count*2 + 1 ] = 0.5f;
		//m_pUV[ count*2 ] = fSegU*i + fSegU/2.0f;
		//m_pUV[ count*2 + 1 ] = 0;
		count++;

		pVertices[ count ].x = agk::SinRad( -fSegX*i ) * radius;
		pVertices[ count ].y = -height/2.0f;
		pVertices[ count ].z = agk::CosRad( -fSegX*i ) * radius;
		pNormals[ count ].x = agk::SinRad( -fSegX*i );
		pNormals[ count ].y = agk::Abs(radius)/height;
		pNormals[ count ].z = agk::CosRad( -fSegX*i );
		pRawUV[ count*2 ] = agk::SinRad( -fSegX*i )/2.0f + 0.5f;
		pRawUV[ count*2 + 1 ] = agk::CosRad( -fSegX*i )/2.0f + 0.5f;
		//pRawUV[ count*2 ] = fSegU*i;
		//pRawUV[ count*2 + 1 ] = 1;
		count++;

		pVertices[ count ].x = agk::SinRad( -fSegX*next ) * radius;
		pVertices[ count ].y = -height/2.0f;
		pVertices[ count ].z = agk::CosRad( -fSegX*next ) * radius;
		pNormals[ count ].x = agk::SinRad( -fSegX*next );
		pNormals[ count ].y = agk::Abs(radius)/height;
		pNormals[ count ].z = agk::CosRad( -fSegX*next );
		pRawUV[ count*2 ] = agk::SinRad( -fSegX*(i+1) )/2.0f + 0.5f;
		pRawUV[ count*2 + 1 ] = agk::CosRad( -fSegX*(i+1) )/2.0f + 0.5f;
		//pRawUV[ count*2 ] = fSegU*(i+1);
		//pRawUV[ count*2 + 1 ] = 1;
		count++;
	}

	// base, just make a flat cone
	for ( int i = 0; i < segments; i++ )
	{
		int next = i+1;
		if ( next >= segments ) next = 0;

		pVertices[ count ].x = agk::SinRad( -fSegX*i ) * radius;
		pVertices[ count ].y = -height/2.0f;
		pVertices[ count ].z = agk::CosRad( -fSegX*i ) * radius;
		pNormals[ count ].x = 0;
		pNormals[ count ].y = -height;
		pNormals[ count ].z = 0;
		pRawUV[ count*2 ] = agk::SinRad( -fSegX*i )/2.0f + 0.5f;
		pRawUV[ count*2 + 1 ] = agk::CosRad( -fSegX*i )/2.0f + 0.5f;
		count++;

		pVertices[ count ].x = 0;
		pVertices[ count ].y = -height/2.0f;
		pVertices[ count ].z = 0;
		pNormals[ count ].x = 0;
		pNormals[ count ].y = -height;
		pNormals[ count ].z = 0;
		pRawUV[ count*2 ] = 0.5f;
		pRawUV[ count*2 + 1 ] = 0.5f;
		count++;

		pVertices[ count ].x = agk::SinRad( -fSegX*next ) * radius;
		pVertices[ count ].y = -height/2.0f;
		pVertices[ count ].z = agk::CosRad( -fSegX*next ) * radius;
		pNormals[ count ].x = 0;
		pNormals[ count ].y = -height;
		pNormals[ count ].z = 0;
		pRawUV[ count*2 ] = agk::SinRad( -fSegX*(i+1) )/2.0f + 0.5f;
		pRawUV[ count*2 + 1 ] = agk::CosRad( -fSegX*(i+1) )/2.0f + 0.5f;
		count++;		
	}

	// normalise normals
	for ( uint32_t i = 0 ; i < m_iNumRawVertices; i++ )
	{
		float length = agk::Sqrt( pNormals[ i ].x*pNormals[ i ].x + pNormals[ i ].y*pNormals[ i ].y + pNormals[ i ].z*pNormals[ i ].z );
		pNormals[ i ].x = pNormals[ i ].x / length;
		pNormals[ i ].y = pNormals[ i ].y / length;
		pNormals[ i ].z = pNormals[ i ].z / length;
	}

	// if inside out, flip normals
	if ( height < 0 )
	{
		for ( uint32_t i = 0 ; i < m_iNumRawVertices*3; i++ )
		{
			pRawNormals[ i ] = -pRawNormals[ i ];
		}
	}
	
	ProcessVertexData();
}

void cMesh::CreateCylinder( float height, float diameter, int segments )
{
	if ( segments < 3 ) segments = 3;
	if ( diameter < 0 ) diameter = -diameter;

	float radius = diameter / 2.0f;

	ClearAttribs();
	m_iFlags |= AGK_MESH_VISIBLE | AGK_MESH_COLLISION;

	m_fScaledBy = 1;

	m_iNumAttribs = 3;
	m_pVertexAttribs = new AGKVertexAttrib[ m_iNumAttribs ];
	
	m_iPosAttrib = 0;
	m_iNormAttrib = 1;
	m_iUVAttrib = 2;
	AGKVertexAttrib *pAttribPos = &m_pVertexAttribs[ m_iPosAttrib ];
	AGKVertexAttrib *pAttribNorm = &m_pVertexAttribs[ m_iNormAttrib ];
	AGKVertexAttrib *pAttribTex = &m_pVertexAttribs[ m_iUVAttrib ];

	pAttribPos->m_iComponents = 3;
	pAttribPos->m_iType = 0;
	pAttribPos->m_szName = new char[ 9 ]; strcpy( pAttribPos->m_szName, "position" );
		
	pAttribNorm->m_iComponents = 3;
	pAttribNorm->m_iType = 0;
	pAttribNorm->m_szName = new char[ 7 ]; strcpy( pAttribNorm->m_szName, "normal" );

	pAttribTex->m_iComponents = 2;
	pAttribTex->m_iType = 0;
	pAttribTex->m_szName = new char[ 3 ]; strcpy( pAttribTex->m_szName, "uv" );

	int faces = segments*4;
	m_iNumRawVertices = faces * 3; 
	m_iNumRawIndices = 0;

	float* pRawVertices = new float[ m_iNumRawVertices * 3 ];	pAttribPos->m_pData = (void*) pRawVertices;
	float* pRawNormals = new float[ m_iNumRawVertices * 3 ];		pAttribNorm->m_pData = (void*) pRawNormals;
	float* pRawUV = new float[ m_iNumRawVertices * 2 ];			pAttribTex->m_pData = (void*) pRawUV;

	cVertex *pVertices = (cVertex*) pRawVertices;
	cVertex *pNormals = (cVertex*) pRawNormals;
	
	float fSegX = 2*PI / segments;
	float fSegU = 1.0f / segments;

	uint32_t count = 0;
	float NormY = height>0 ? 1.0f : -1.0f;

	// top, just make a flat cone
	for ( int i = 0; i < segments; i++ )
	{
		int next = i+1;
		if ( next >= segments ) next = 0;

		pVertices[ count ].x = 0;
		pVertices[ count ].y = height/2.0f;
		pVertices[ count ].z = 0;
		pNormals[ count ].x = 0;
		pNormals[ count ].y = NormY;
		pNormals[ count ].z = 0;
		pRawUV[ count*2 ] = 0.5f;
		pRawUV[ count*2 + 1 ] = 0.5f;
		count++;

		pVertices[ count ].x = agk::SinRad( -fSegX*i ) * radius;
		pVertices[ count ].y = height/2.0f;
		pVertices[ count ].z = agk::CosRad( -fSegX*i ) * radius;
		pNormals[ count ].x = 0;
		pNormals[ count ].y = NormY;
		pNormals[ count ].z = 0;
		pRawUV[ count*2 ] = agk::SinRad( -fSegX*i )/2.0f + 0.5f;
		pRawUV[ count*2 + 1 ] = agk::CosRad( -fSegX*i )/2.0f + 0.5f;
		count++;

		pVertices[ count ].x = agk::SinRad( -fSegX*next ) * radius;
		pVertices[ count ].y = height/2.0f;
		pVertices[ count ].z = agk::CosRad( -fSegX*next ) * radius;
		pNormals[ count ].x = 0;
		pNormals[ count ].y = NormY;
		pNormals[ count ].z = 0;
		pRawUV[ count*2 ] = agk::SinRad( -fSegX*(i+1) )/2.0f + 0.5f;
		pRawUV[ count*2 + 1 ] = agk::CosRad( -fSegX*(i+1) )/2.0f + 0.5f;
		count++;		
	}
	
	// middle part, two polygons per segment
	for ( int i = 0; i < segments; i++ )
	{
		int next = i+1;
		if ( next >= segments ) next = 0;

		// polygon 1
		pVertices[ count ].x = agk::SinRad( -fSegX*i ) * radius;
		pVertices[ count ].y = height/2.0f;
		pVertices[ count ].z = agk::CosRad( -fSegX*i ) * radius;
		pNormals[ count ].x = agk::SinRad( -fSegX*i );
		pNormals[ count ].y = 0;
		pNormals[ count ].z = agk::CosRad( -fSegX*i );
		pRawUV[ count*2 ] = fSegU*i;
		pRawUV[ count*2 + 1 ] = 0;
		count++;

		pVertices[ count ].x = agk::SinRad( -fSegX*i ) * radius;
		pVertices[ count ].y = -height/2.0f;
		pVertices[ count ].z = agk::CosRad( -fSegX*i ) * radius;
		pNormals[ count ].x = agk::SinRad( -fSegX*i );
		pNormals[ count ].y = 0;
		pNormals[ count ].z = agk::CosRad( -fSegX*i );
		pRawUV[ count*2 ] = fSegU*i;
		pRawUV[ count*2 + 1 ] = 1;
		count++;

		pVertices[ count ].x = agk::SinRad( -fSegX*next ) * radius;
		pVertices[ count ].y = -height/2.0f;
		pVertices[ count ].z = agk::CosRad( -fSegX*next ) * radius;
		pNormals[ count ].x = agk::SinRad( -fSegX*next );
		pNormals[ count ].y = 0;
		pNormals[ count ].z = agk::CosRad( -fSegX*next );
		pRawUV[ count*2 ] = fSegU*(i+1);
		pRawUV[ count*2 + 1 ] = 1;
		count++;

		// polygon 2
		pVertices[ count ].x = agk::SinRad( -fSegX*i ) * radius;
		pVertices[ count ].y = height/2.0f;
		pVertices[ count ].z = agk::CosRad( -fSegX*i ) * radius;
		pNormals[ count ].x = agk::SinRad( -fSegX*i );
		pNormals[ count ].y = 0;
		pNormals[ count ].z = agk::CosRad( -fSegX*i );
		pRawUV[ count*2 ] = fSegU*i;
		pRawUV[ count*2 + 1 ] = 0;
		count++;

		pVertices[ count ].x = agk::SinRad( -fSegX*next ) * radius;
		pVertices[ count ].y = -height/2.0f;
		pVertices[ count ].z = agk::CosRad( -fSegX*next ) * radius;
		pNormals[ count ].x = agk::SinRad( -fSegX*next );
		pNormals[ count ].y = 0;
		pNormals[ count ].z = agk::CosRad( -fSegX*next );
		pRawUV[ count*2 ] = fSegU*(i+1);
		pRawUV[ count*2 + 1 ] = 1;
		count++;

		pVertices[ count ].x = agk::SinRad( -fSegX*next ) * radius;
		pVertices[ count ].y = height/2.0f;
		pVertices[ count ].z = agk::CosRad( -fSegX*next ) * radius;
		pNormals[ count ].x = agk::SinRad( -fSegX*next );
		pNormals[ count ].y = 0;
		pNormals[ count ].z = agk::CosRad( -fSegX*next );
		pRawUV[ count*2 ] = fSegU*(i+1);
		pRawUV[ count*2 + 1 ] = 0;
		count++;
	}

	// base, just make a flat cone
	for ( int i = 0; i < segments; i++ )
	{
		int next = i+1;
		if ( next >= segments ) next = 0;

		pVertices[ count ].x = agk::SinRad( -fSegX*i ) * radius;
		pVertices[ count ].y = -height/2.0f;
		pVertices[ count ].z = agk::CosRad( -fSegX*i ) * radius;
		pNormals[ count ].x = 0;
		pNormals[ count ].y = -NormY;
		pNormals[ count ].z = 0;
		pRawUV[ count*2 ] = agk::SinRad( -fSegX*i )/2.0f + 0.5f;
		pRawUV[ count*2 + 1 ] = agk::CosRad( -fSegX*i )/2.0f + 0.5f;
		count++;

		pVertices[ count ].x = 0;
		pVertices[ count ].y = -height/2.0f;
		pVertices[ count ].z = 0;
		pNormals[ count ].x = 0;
		pNormals[ count ].y = -NormY;
		pNormals[ count ].z = 0;
		pRawUV[ count*2 ] = 0.5f;
		pRawUV[ count*2 + 1 ] = 0.5f;
		count++;

		pVertices[ count ].x = agk::SinRad( -fSegX*next ) * radius;
		pVertices[ count ].y = -height/2.0f;
		pVertices[ count ].z = agk::CosRad( -fSegX*next ) * radius;
		pNormals[ count ].x = 0;
		pNormals[ count ].y = -NormY;
		pNormals[ count ].z = 0;
		pRawUV[ count*2 ] = agk::SinRad( -fSegX*(i+1) )/2.0f + 0.5f;
		pRawUV[ count*2 + 1 ] = agk::CosRad( -fSegX*(i+1) )/2.0f + 0.5f;
		count++;		
	}

	// normals already normalised

	// if inside out, flip normals
	if ( height < 0 )
	{
		for ( uint32_t i = 0 ; i < m_iNumRawVertices*3; i++ )
		{
			pRawNormals[ i ] = -pRawNormals[ i ];
		}
	}
	
	ProcessVertexData();
}

void cMesh::CreatePlane( float width, float height )
{
	ClearAttribs();

	m_fScaledBy = 1;
	m_iFlags |= AGK_MESH_VISIBLE | AGK_MESH_COLLISION;

	m_iNumAttribs = 3;
	m_pVertexAttribs = new AGKVertexAttrib[ m_iNumAttribs ];
	
	m_iPosAttrib = 0;
	m_iNormAttrib = 1;
	m_iUVAttrib = 2;
	AGKVertexAttrib *pAttribPos = &m_pVertexAttribs[ m_iPosAttrib ];
	AGKVertexAttrib *pAttribNorm = &m_pVertexAttribs[ m_iNormAttrib ];
	AGKVertexAttrib *pAttribTex = &m_pVertexAttribs[ m_iUVAttrib ];

	pAttribPos->m_iComponents = 3;
	pAttribPos->m_iType = 0;
	pAttribPos->m_szName = new char[ 9 ]; strcpy( pAttribPos->m_szName, "position" );
		
	pAttribNorm->m_iComponents = 3;
	pAttribNorm->m_iType = 0;
	pAttribNorm->m_szName = new char[ 7 ]; strcpy( pAttribNorm->m_szName, "normal" );

	pAttribTex->m_iComponents = 2;
	pAttribTex->m_iType = 0;
	pAttribTex->m_szName = new char[ 3 ]; strcpy( pAttribTex->m_szName, "uv" );

	m_iNumRawVertices = 12; 
	m_iNumRawIndices = 0;

	float* pRawVertices = new float[ m_iNumRawVertices * 3 ];	pAttribPos->m_pData = (void*) pRawVertices;
	float* pRawNormals = new float[ m_iNumRawVertices * 3 ];		pAttribNorm->m_pData = (void*) pRawNormals;
	float* pRawUV = new float[ m_iNumRawVertices * 2 ];			pAttribTex->m_pData = (void*) pRawUV;

	cVertex *pVertices = (cVertex*) pRawVertices;

	width /= 2;
	height /= 2;

	// Face 1
	pVertices[ 0 ].x = -width;
	pVertices[ 0 ].y = height;
	pVertices[ 0 ].z = 0;

	pVertices[ 1 ].x = -width;
	pVertices[ 1 ].y = -height;
	pVertices[ 1 ].z = 0;

	pVertices[ 2 ].x = width;
	pVertices[ 2 ].y = height;
	pVertices[ 2 ].z = 0;

	pVertices[ 3 ].x = width;
	pVertices[ 3 ].y = height;
	pVertices[ 3 ].z = 0;

	pVertices[ 4 ].x = -width;
	pVertices[ 4 ].y = -height;
	pVertices[ 4 ].z = 0;

	pVertices[ 5 ].x = width;
	pVertices[ 5 ].y = -height;
	pVertices[ 5 ].z = 0;

	// Face 2
	pVertices[ 6 ].x = width;
	pVertices[ 6 ].y = height;
	pVertices[ 6 ].z = 0;

	pVertices[ 7 ].x = width;
	pVertices[ 7 ].y = -height;
	pVertices[ 7 ].z = 0;

	pVertices[ 8 ].x = -width;
	pVertices[ 8 ].y = height;
	pVertices[ 8 ].z = 0;

	pVertices[ 9 ].x = -width;
	pVertices[ 9 ].y = height;
	pVertices[ 9 ].z = 0;

	pVertices[ 10 ].x = width;
	pVertices[ 10 ].y = -height;
	pVertices[ 10 ].z = 0;

	pVertices[ 11 ].x = -width;
	pVertices[ 11 ].y = -height;
	pVertices[ 11 ].z = 0;

	// Normal 1
	for ( int i = 0; i < 6; i++ )
	{
		pRawNormals[ i*3 ] = 0;
		pRawNormals[ i*3 + 1 ] = 0;
		pRawNormals[ i*3 + 2 ] = -1;
	}

	// Normal 2
	for ( int i = 6; i < 12; i++ )
	{
		pRawNormals[ i*3 ] = 0;
		pRawNormals[ i*3 + 1 ] = 0;
		pRawNormals[ i*3 + 2 ] = 1;
	}

	// UVs 1-6
	for ( int i = 0; i < 2; i++ )
	{
		pRawUV[ i*12 + 0 ] = 0.0f;
		pRawUV[ i*12 + 1 ] = 0.0f;

		pRawUV[ i*12 + 2 ] = 0.0f;
		pRawUV[ i*12 + 3 ] = 1.0f;

		pRawUV[ i*12 + 4 ] = 1.0f;
		pRawUV[ i*12 + 5 ] = 0.0f;

		pRawUV[ i*12 + 6 ] = 1.0f;
		pRawUV[ i*12 + 7 ] = 0.0f;

		pRawUV[ i*12 + 8 ] = 0.0f;
		pRawUV[ i*12 + 9 ] = 1.0f;
		
		pRawUV[ i*12 + 10 ] = 1.0f;
		pRawUV[ i*12 + 11 ] = 1.0f;
	}
		
	ProcessVertexData();
}

void cMesh::CreateQuad()
{
	ClearAttribs();

	m_fScaledBy = 1;
	m_iFlags &= ~AGK_MESH_COLLISION;
	m_iFlags |= AGK_MESH_VISIBLE;

	m_iNumAttribs = 1;
	m_pVertexAttribs = new AGKVertexAttrib[ m_iNumAttribs ];
	
	m_iPosAttrib = 0;
	AGKVertexAttrib *pAttribPos = &m_pVertexAttribs[ m_iPosAttrib ];
	
	pAttribPos->m_iComponents = 3;
	pAttribPos->m_iType = 0;
	pAttribPos->m_szName = new char[ 9 ]; strcpy( pAttribPos->m_szName, "position" );
		
	m_iNumRawVertices = 6; 
	m_iNumRawIndices = 0;

	float* pRawVertices = new float[ m_iNumRawVertices * 3 ];	
	pAttribPos->m_pData = (void*) pRawVertices;
	
	cVertex *pVertices = (cVertex*) pRawVertices;

	float width = 1;
	float height = 1;

	// Face 1
	pVertices[ 0 ].x = -width;
	pVertices[ 0 ].y = height;
	pVertices[ 0 ].z = 0;

	pVertices[ 1 ].x = -width;
	pVertices[ 1 ].y = -height;
	pVertices[ 1 ].z = 0;

	pVertices[ 2 ].x = width;
	pVertices[ 2 ].y = height;
	pVertices[ 2 ].z = 0;

	pVertices[ 3 ].x = width;
	pVertices[ 3 ].y = height;
	pVertices[ 3 ].z = 0;

	pVertices[ 4 ].x = -width;
	pVertices[ 4 ].y = -height;
	pVertices[ 4 ].z = 0;

	pVertices[ 5 ].x = width;
	pVertices[ 5 ].y = -height;
	pVertices[ 5 ].z = 0;

	ProcessVertexData();
}

void cMesh::CreateCapsule( float diameter, int rows, int columns, float height, int axis )
{
	if ( rows < 2 ) rows = 2;
	if ( columns < 3 ) columns = 3;

	float radius = diameter / 2.0f;

	ClearAttribs();
	m_fScaledBy = 1;
	m_iFlags |= AGK_MESH_VISIBLE | AGK_MESH_COLLISION;

	m_iNumAttribs = 3;
	m_pVertexAttribs = new AGKVertexAttrib[ m_iNumAttribs ];

	m_iPosAttrib = 0;
	m_iNormAttrib = 1;
	m_iUVAttrib = 2;
	AGKVertexAttrib *pAttribPos = &m_pVertexAttribs[ m_iPosAttrib ];
	AGKVertexAttrib *pAttribNorm = &m_pVertexAttribs[ m_iNormAttrib ];
	AGKVertexAttrib *pAttribTex = &m_pVertexAttribs[ m_iUVAttrib ];

	pAttribPos->m_iComponents = 3;
	pAttribPos->m_iType = 0;
	pAttribPos->m_szName = new char[ 9 ]; strcpy( pAttribPos->m_szName, "position" );
		
	pAttribNorm->m_iComponents = 3;
	pAttribNorm->m_iType = 0;
	pAttribNorm->m_szName = new char[ 7 ]; strcpy( pAttribNorm->m_szName, "normal" );

	pAttribTex->m_iComponents = 2;
	pAttribTex->m_iType = 0;
	pAttribTex->m_szName = new char[ 3 ]; strcpy( pAttribTex->m_szName, "uv" );

	int faces = (rows-1) * columns * 2;
	m_iNumRawVertices = (rows+1) * (columns+1); 
	m_iNumRawIndices = faces*3;

	float* pRawVertices = new float[ m_iNumRawVertices * 3 ];	pAttribPos->m_pData = (void*) pRawVertices;
	float* pRawNormals = new float[ m_iNumRawVertices * 3 ];	pAttribNorm->m_pData = (void*) pRawNormals;
	float* pRawUV = new float[ m_iNumRawVertices * 2 ];			pAttribTex->m_pData = (void*) pRawUV;
	m_pRawIndices = new uint32_t[ m_iNumRawIndices ];

	cVertex *pVertices = (cVertex*) pRawVertices;
//	cVertex *pNormals = (cVertex*) pRawNormals;
	
	float fSegY = PI / rows;
	float fSegX = 2*PI / columns;

	float fSegU = 1.0f / columns;
	float fSegV = 1.0f / rows;

	height = (height - diameter)/2.0f;

	// vertices
	uint32_t count = 0;
	for ( int j = 0; j <= rows; j++ )
	{
		float fSY = agk::SinRad( fSegY*j );
		float fCY = agk::CosRad( fSegY*j );

		for ( int i = 0; i <= columns; i++ )
		{
			pVertices[ count ].x = agk::SinRad( -fSegX*i ) * fSY * radius;
			if ( fCY * radius > 0 ) pVertices[ count ].y = fCY * radius + height;
			else pVertices[ count ].y = fCY * radius - height;
			pVertices[ count ].z = agk::CosRad( -fSegX*i ) * fSY * radius;

			if ( j == 0 || j == rows ) pRawUV[ count*2 ] = fSegU*i + fSegU/2.0f;
			else pRawUV[ count*2 ] = fSegU*i;
			pRawUV[ count*2 + 1 ] = fSegV*j;
			count++;
		}
	}

	// normals
	for ( uint32_t i = 0 ; i < m_iNumRawVertices*3; i++ )
	{
		pRawNormals[ i ] = pRawVertices[ i ] / radius;
	}

	// indices
	uint32_t countI = 0;
	// top row
	for ( int i = 0; i < columns; i++ )
	{
		int next = i+1;

		m_pRawIndices[ countI*3 + 0 ] = i;
		m_pRawIndices[ countI*3 + 1 ] = columns+1 + i;
		m_pRawIndices[ countI*3 + 2 ] = columns+1 + next;
		countI++;
	}

	// middle rows
	for ( int j = 1; j < rows-1; j++ )
	{
		for ( int i = 0; i < columns; i++ )
		{
			int next = i+1;

			m_pRawIndices[ countI*3 + 0 ] = (columns+1)*j + i;
			m_pRawIndices[ countI*3 + 1 ] = (columns+1)*(j+1) + i;
			m_pRawIndices[ countI*3 + 2 ] = (columns+1)*j + next;
			countI++;

			m_pRawIndices[ countI*3 + 0 ] = (columns+1)*j + next;
			m_pRawIndices[ countI*3 + 1 ] = (columns+1)*(j+1) + i;
			m_pRawIndices[ countI*3 + 2 ] = (columns+1)*(j+1) + next;
			countI++;
		}
	}

	// bottom row
	for ( int i = 0; i < columns; i++ )
	{
		int next = i+1;

		m_pRawIndices[ countI*3 + 0 ] = (columns+1)*(rows-1) + i;
		m_pRawIndices[ countI*3 + 1 ] = (columns+1)*rows + i;
		m_pRawIndices[ countI*3 + 2 ] = (columns+1)*(rows-1) + next;
		countI++;
	}
	
	AGKQuaternion rotationQ;
	if( axis == Z_AXIS ) rotationQ.MakeFromEulerYXZ(90.0,0.0,0.0);
	if( axis == X_AXIS ) rotationQ.MakeFromEulerYXZ(0.0,0.0,90.0);

	RotateMesh( rotationQ.w, rotationQ.x, rotationQ.y, rotationQ.z, 0 );
	ProcessVertexData();
}

void cMesh::CreateFromHeightMap( unsigned short *pValues, int totalSegsX, int totalSegsZ, int startX, int endX, int startZ, int endZ, float width, float height, float length )
{
	ClearAttribs();
	m_fScaledBy = 1;
	m_iFlags |= AGK_MESH_VISIBLE | AGK_MESH_COLLISION;

	m_iNumAttribs = 3;
	m_pVertexAttribs = new AGKVertexAttrib[ m_iNumAttribs ];

	m_iPosAttrib = 0;
	m_iNormAttrib = 1;
	m_iUVAttrib = 2;
	AGKVertexAttrib *pAttribPos = &m_pVertexAttribs[ m_iPosAttrib ];
	AGKVertexAttrib *pAttribNorm = &m_pVertexAttribs[ m_iNormAttrib ];
	AGKVertexAttrib *pAttribTex = &m_pVertexAttribs[ m_iUVAttrib ];

	pAttribPos->m_iComponents = 3;
	pAttribPos->m_iType = 0;
	pAttribPos->m_szName = new char[ 9 ]; strcpy( pAttribPos->m_szName, "position" );
		
	pAttribNorm->m_iComponents = 3;
	pAttribNorm->m_iType = 0;
	pAttribNorm->m_szName = new char[ 7 ]; strcpy( pAttribNorm->m_szName, "normal" );

	pAttribTex->m_iComponents = 2;
	pAttribTex->m_iType = 0;
	pAttribTex->m_szName = new char[ 3 ]; strcpy( pAttribTex->m_szName, "uv" );

	// total number of vertices in the main array
	int totalVertsX = totalSegsX + 1;
	int totalVertsZ = totalSegsZ + 1;

	// number of segments to use in this sub array
	int segX = endX - startX;
	int segZ = endZ - startZ;

	// number of vertices in this sub array
	int vertX = segX + 1;
	int vertZ = segZ + 1;

	// segment size, same for both main and sub arrays
	float fSegSizeX = width / totalSegsX;
	float fSegSizeZ = length / totalSegsZ;

	m_iNumRawVertices = vertX*vertZ; 
	m_iNumRawIndices = (segX*2 + 4)*segZ - 2; // using triangle strip

	float* pRawVertices = new float[ m_iNumRawVertices * 3 ];	pAttribPos->m_pData = (void*) pRawVertices;
	float* pRawNormals = new float[ m_iNumRawVertices * 3 ];	pAttribNorm->m_pData = (void*) pRawNormals;
	float* pRawUV = new float[ m_iNumRawVertices * 2 ];			pAttribTex->m_pData = (void*) pRawUV;
	m_pRawIndices = new uint32_t[ m_iNumRawIndices ];

	cVertex *pVertices = (cVertex*) pRawVertices;
	cVertex *pNormals = (cVertex*) pRawNormals;

	// vertices
	for ( int z = startZ; z <= endZ; z++ )
	{
		for ( int x = startX; x <= endX; x++ )
		{
			uint32_t index = (z * totalVertsX) + x;
			uint32_t subIndex = ((z-startZ)*vertX) + (x-startX);

			pVertices[ subIndex ].x = x*fSegSizeX;
			pVertices[ subIndex ].y = pValues[index]/65535.0f * height;
			pVertices[ subIndex ].z = length - (z*fSegSizeZ);

			pRawUV[ subIndex*2 + 0 ] = (x*fSegSizeX) / width;
			pRawUV[ subIndex*2 + 1 ] = (z*fSegSizeZ) / length;
		}
	}
	
	// normals
	//cVertex *pTempNormals = new cVertex[ m_iNumRawVertices ];
	for ( int z = startZ; z <= endZ; z++ )
	{
		uint32_t z1 = z; if ( z > 0 ) z1--;
		uint32_t z2 = z; if ( z < totalVertsZ-1 ) z2++;

		for ( int x = startX; x <= endX; x++ )
		{
			uint32_t x1 = x; if ( x > 0 ) x1--;
			uint32_t x2 = x; if ( x < totalVertsX-1 ) x2++;
			
			uint32_t index1, index2;
			float diffX, diffZ;
			float nx, ny, nz;

			index1 = (z * totalVertsX) + x1;
			index2 = (z * totalVertsX) + x2;
			diffX = (float) (pValues[index2] - pValues[index1]);
			diffX = diffX/65535.0f * height;
			nx = -diffX / fSegSizeX;

			index1 = (z1 * totalVertsX) + x;
			index2 = (z2 * totalVertsX) + x;
			diffZ = (float) (pValues[index2] - pValues[index1]);
			diffZ = diffZ/65535.0f * height;
			nz = diffZ / fSegSizeZ;

			ny = 2;
						
			float length = nx*nx + ny*ny + nz*nz;
			length = 1.0f / agk::Sqrt(length);

			uint32_t subIndex = ((z-startZ)*vertX) + (x-startX);
			pNormals[ subIndex ].x = nx * length;
			pNormals[ subIndex ].y = ny * length;
			pNormals[ subIndex ].z = nz * length;
		}
	}

	/*
	// smooth normals
	for ( int z = startZ; z <= endZ; z++ )
	{
		uint32_t z1 = z; if ( z > startZ ) z1--;
		uint32_t z2 = z; if ( z < endZ ) z2++;

		for ( int x = startX; x <= endX; x++ )
		{
			uint32_t x1 = x; if ( x > startX ) x1--;
			uint32_t x2 = x; if ( x < endX ) x2++;

			uint32_t subIndex = ((z-startZ)*vertX) + (x-startX);
			uint32_t subIndexZ1 = ((z1-startZ)*vertX) + (x-startX);
			uint32_t subIndexZ2 = ((z2-startZ)*vertX) + (x-startX);
			uint32_t subIndexX1 = ((z-startZ)*vertX) + (x1-startX);
			uint32_t subIndexX2 = ((z-startZ)*vertX) + (x2-startX);

			uint32_t subIndexX1Z1 = ((z1-startZ)*vertX) + (x1-startX);
			uint32_t subIndexX2Z1 = ((z1-startZ)*vertX) + (x2-startX);
			uint32_t subIndexX1Z2 = ((z2-startZ)*vertX) + (x1-startX);
			uint32_t subIndexX2Z2 = ((z2-startZ)*vertX) + (x2-startX);
			
			float nx, ny, nz;
			nx = pTempNormals[ subIndex ].x;
			ny = pTempNormals[ subIndex ].y;
			nz = pTempNormals[ subIndex ].z;

			nx += pTempNormals[ subIndexX1 ].x;
			ny += pTempNormals[ subIndexX1 ].y;
			nz += pTempNormals[ subIndexX1 ].z;

			nx += pTempNormals[ subIndexX2 ].x;
			ny += pTempNormals[ subIndexX2 ].y;
			nz += pTempNormals[ subIndexX2 ].z;

			nx += pTempNormals[ subIndexZ1 ].x;
			ny += pTempNormals[ subIndexZ1 ].y;
			nz += pTempNormals[ subIndexZ1 ].z;

			nx += pTempNormals[ subIndexZ2 ].x;
			ny += pTempNormals[ subIndexZ2 ].y;
			nz += pTempNormals[ subIndexZ2 ].z;

			nx += pTempNormals[ subIndexX1Z1 ].x;
			ny += pTempNormals[ subIndexX1Z1 ].y;
			nz += pTempNormals[ subIndexX1Z1 ].z;

			nx += pTempNormals[ subIndexX2Z1 ].x;
			ny += pTempNormals[ subIndexX2Z1 ].y;
			nz += pTempNormals[ subIndexX2Z1 ].z;

			nx += pTempNormals[ subIndexX1Z2 ].x;
			ny += pTempNormals[ subIndexX1Z2 ].y;
			nz += pTempNormals[ subIndexX1Z2 ].z;

			nx += pTempNormals[ subIndexX2Z2 ].x;
			ny += pTempNormals[ subIndexX2Z2 ].y;
			nz += pTempNormals[ subIndexX2Z2 ].z;
						
			float length = nx*nx + ny*ny + nz*nz;
			length = 1.0f / agk::Sqrt(length);

			pNormals[ subIndex ].x = nx * length;
			pNormals[ subIndex ].y = ny * length;
			pNormals[ subIndex ].z = nz * length;
		}
	}
	*/

	// indices
	uint32_t countI = 0;
	for ( int z = 0; z < segZ; z++ )
	{
		m_pRawIndices[ countI++ ] = z*vertX;
		m_pRawIndices[ countI++ ] = (z+1)*vertX;

		for ( int x = 0; x < segX; x++ )
		{
			m_pRawIndices[ countI++ ] = z*vertX + x+1;
			m_pRawIndices[ countI++ ] = (z+1)*vertX + x+1;
		}

		if ( z < segZ-1 ) 
		{
			m_pRawIndices[ countI++ ] = (z+1)*vertX + segX;
			m_pRawIndices[ countI++ ] = (z+1)*vertX;
		}
	}

	if ( countI != m_iNumRawIndices ) 
	{
		uString info;
		info.Format( "Num Indices: %d does not match index count: %d", m_iNumRawIndices, countI );
		agk::Warning( info );
	}

	m_iPrimitiveType = AGK_PRIMITIVE_TRIANGLE_STRIP;
	
	ProcessVertexData();
}

void cMesh::CreateMesh( aiMesh *pMesh, float height, int scaleMode )
{
	ClearAttribs();

	m_iFlags |= AGK_MESH_VISIBLE | AGK_MESH_COLLISION;

	float *pV = 0;
	float *pVT0 = 0;
	float *pVT1 = 0;
	float *pVN = 0;
	float *pVTan = 0;
	float *pVBin = 0;
	unsigned char *pVCol = 0;
	float *pVWeights = 0;
	unsigned char *pVIndices = 0;
	unsigned char *pWeightCount = 0;

	m_iNumAttribs = 1;
	m_iNumRawVertices = pMesh->mNumVertices;
	m_sName.SetStr( pMesh->mName.C_Str() );

	pV = new float[ m_iNumRawVertices*3 ];

	if ( pMesh->mTextureCoords[0] ) 
	{
		pVT0 = new float[ m_iNumRawVertices*2 ];
		m_iNumAttribs++;
	}
	if ( pMesh->mTextureCoords[1] ) 
	{
		pVT1 = new float[ m_iNumRawVertices*2 ];
		m_iNumAttribs++;
	}
	if ( pMesh->mNormals ) 
	{
		pVN = new float[ m_iNumRawVertices*3 ];
		m_iNumAttribs++;
	}
	if ( pMesh->mTangents ) 
	{
		pVTan = new float[ m_iNumRawVertices*3 ];
		m_iNumAttribs++;
	}
	if ( pMesh->mBitangents ) 
	{
		pVBin = new float[ m_iNumRawVertices*3 ];
		m_iNumAttribs++;
	}
	if ( pMesh->mColors[0] ) 
	{
		pVCol = new unsigned char[ m_iNumRawVertices*4 ];
		m_iNumAttribs++;
	}
	if ( pMesh->HasBones() && m_pObject->m_pSkeleton )
	{
		m_iFlags |= AGK_MESH_HAS_BONES;

		pVWeights = new float[ m_iNumRawVertices*4 ];
		memset( pVWeights, 0, m_iNumRawVertices*4*sizeof(float) );
		m_iNumAttribs++;

		pVIndices = new unsigned char[ m_iNumRawVertices*4 ];
		memset( pVIndices, 0, m_iNumRawVertices*4 );
		m_iNumAttribs++;
	}

	m_pVertexAttribs = new AGKVertexAttrib[ m_iNumAttribs ];

	AGKVertexAttrib *pPositions = &m_pVertexAttribs[ 0 ];
	pPositions->m_iComponents = 3;
	pPositions->m_iType = 0;
	pPositions->m_szName = new char[ 9 ]; strcpy( pPositions->m_szName, "position" );
	pPositions->m_pData = (void*) pV;
	m_iPosAttrib = 0;
	
	uint32_t currAttrib = 1;

	// put normals and UV0 first to match other primitives
	if ( pVN )
	{
		m_iNormAttrib = currAttrib;
		AGKVertexAttrib *pNormals = &m_pVertexAttribs[ currAttrib++ ];
		pNormals->m_iComponents = 3;
		pNormals->m_iType = 0;
		pNormals->m_szName = new char[ 7 ]; strcpy( pNormals->m_szName, "normal" );
		pNormals->m_pData = (void*) pVN;
	}
	if ( pVT0 )
	{
		m_iUVAttrib = currAttrib;
		AGKVertexAttrib *pTexCoords = &m_pVertexAttribs[ currAttrib++ ];
		pTexCoords->m_iComponents = 2;
		pTexCoords->m_iType = 0;
		pTexCoords->m_szName = new char[ 3 ]; strcpy( pTexCoords->m_szName, "uv" );
		pTexCoords->m_pData = (void*) pVT0;
	}

	if ( pVTan )
	{
		m_iTangentAttrib = currAttrib;
		AGKVertexAttrib *pTangents = &m_pVertexAttribs[ currAttrib++ ];
		pTangents->m_iComponents = 3;
		pTangents->m_iType = 0;
		pTangents->m_szName = new char[ 8 ]; strcpy( pTangents->m_szName, "tangent" );
		pTangents->m_pData = (void*) pVTan;
	}
	if ( pVBin )
	{
		m_iBiNormAttrib = currAttrib;
		AGKVertexAttrib *pBiNormals = &m_pVertexAttribs[ currAttrib++ ];
		pBiNormals->m_iComponents = 3;
		pBiNormals->m_iType = 0;
		pBiNormals->m_szName = new char[ 10 ]; strcpy( pBiNormals->m_szName, "binormal" );
		pBiNormals->m_pData = (void*) pVBin;
	}
		
	if ( pVT1 )
	{
		m_iUV1Attrib = currAttrib;
		AGKVertexAttrib *pTexCoords = &m_pVertexAttribs[ currAttrib++ ];
		pTexCoords->m_iComponents = 2;
		pTexCoords->m_iType = 0;
		pTexCoords->m_szName = new char[ 4 ]; strcpy( pTexCoords->m_szName, "uv1" );
		pTexCoords->m_pData = (void*) pVT1;
	}

	if ( pVCol )
	{
		m_iColorAttrib = currAttrib;
		AGKVertexAttrib *pColors = &m_pVertexAttribs[ currAttrib++ ];
		pColors->m_iComponents = 4;
		pColors->m_iType = 1;
		pColors->m_szName = new char[ 6 ]; strcpy( pColors->m_szName, "color" );
		pColors->m_pData = (void*) pVCol;
		pColors->m_iNormalize = true;
	}

	if ( pVWeights )
	{
		m_iBoneWeightsAttrib = currAttrib;
		AGKVertexAttrib *pBoneWeights = &m_pVertexAttribs[ currAttrib++ ];
		pBoneWeights->m_iComponents = 4;
		pBoneWeights->m_iType = 0;
		pBoneWeights->m_szName = new char[ 12 ]; strcpy( pBoneWeights->m_szName, "boneweights" );
		pBoneWeights->m_pData = (void*) pVWeights;

		m_iBoneIndicesAttrib = currAttrib;
		AGKVertexAttrib *pBoneIndices = &m_pVertexAttribs[ currAttrib++ ];
		pBoneIndices->m_iComponents = 4;
		pBoneIndices->m_iType = 1;
		pBoneIndices->m_szName = new char[ 12 ]; strcpy( pBoneIndices->m_szName, "boneindices" );
		pBoneIndices->m_pData = (void*) pVIndices;
		pBoneIndices->m_iNormalize = false;
	}

	float maxHeight = -1000000000;
	float minHeight = 1000000000;

	// load data into AGK arrays
	for ( uint32_t i = 0; i < pMesh->mNumVertices; i++ )
	{
		if ( pMesh->mVertices[ i ].y > maxHeight ) maxHeight = pMesh->mVertices[ i ].y;
		if ( pMesh->mVertices[ i ].y < minHeight ) minHeight = pMesh->mVertices[ i ].y;

		pV[ i*3 + 0 ] = pMesh->mVertices[ i ].x;
		pV[ i*3 + 1 ] = pMesh->mVertices[ i ].y;
		pV[ i*3 + 2 ] = pMesh->mVertices[ i ].z;

		if ( pVN )
		{
			float nx = pMesh->mNormals[ i ].x;
			float ny = pMesh->mNormals[ i ].y;
			float nz = pMesh->mNormals[ i ].z;

			float length = sqrt(nx*nx + ny*ny + nz*nz);
			if ( length > 0.00001f ) length = 1 / length;
			else 
			{
				ny = 1;
				length = 1;
			}

			pVN[ i*3 + 0 ] = nx * length;
			pVN[ i*3 + 1 ] = ny * length;
			pVN[ i*3 + 2 ] = nz * length;
		}

		if ( pVTan )
		{
			pVTan[ i*3 + 0 ] = pMesh->mTangents[ i ].x;
			pVTan[ i*3 + 1 ] = pMesh->mTangents[ i ].y;
			pVTan[ i*3 + 2 ] = pMesh->mTangents[ i ].z;
		}

		if ( pVBin )
		{
			pVBin[ i*3 + 0 ] = pMesh->mBitangents[ i ].x;
			pVBin[ i*3 + 1 ] = pMesh->mBitangents[ i ].y;
			pVBin[ i*3 + 2 ] = pMesh->mBitangents[ i ].z;
		}

		if ( pVCol )
		{
			pVCol[ i*4 + 0 ] = (unsigned char)(pMesh->mColors[ 0 ][ i ].r*255);
			pVCol[ i*4 + 1 ] = (unsigned char)(pMesh->mColors[ 0 ][ i ].g*255);
			pVCol[ i*4 + 2 ] = (unsigned char)(pMesh->mColors[ 0 ][ i ].b*255);
			pVCol[ i*4 + 3 ] = (unsigned char)(pMesh->mColors[ 0 ][ i ].a*255);
		}

		if ( pVT0 )
		{
			pVT0[ i*2 + 0 ] = pMesh->mTextureCoords[ 0 ][ i ].x;
			pVT0[ i*2 + 1 ] = pMesh->mTextureCoords[ 0 ][ i ].y;
		}

		if ( pVT1 )
		{
			pVT1[ i*2 + 0 ] = pMesh->mTextureCoords[ 1 ][ i ].x;
			pVT1[ i*2 + 1 ] = pMesh->mTextureCoords[ 1 ][ i ].y;
		}
	}

	if ( HasBones() )
	{
		pWeightCount = new unsigned char[ m_iNumRawVertices ]; // just to count the weights as we find them
		memset( pWeightCount, 0, m_iNumRawVertices );

		for( uint32_t b = 0; b < pMesh->mNumBones; b++ )
		{
			uint32_t boneIndex = m_pObject->m_pSkeleton->GetBoneIndex( pMesh->mBones[b]->mName.C_Str() );

			for ( uint32_t w = 0; w < pMesh->mBones[b]->mNumWeights; w++ )
			{
				uint32_t vertexIndex = pMesh->mBones[b]->mWeights[w].mVertexId;
				if ( pWeightCount[vertexIndex] >= 4 ) 
				{
					static bool warned = false;
					if ( !warned )
					{
						uString err;
						err.Format( "Object %d has more than 4 bone weights per vertex, AGK only supports 4 weights, the rest will be ignored", m_pObject->m_iID );
						agk::Warning( err );
						warned = true;
					}
				}
				else
				{
					pVWeights[ vertexIndex*4 + pWeightCount[vertexIndex] ] = pMesh->mBones[b]->mWeights[w].mWeight;
					pVIndices[ vertexIndex*4 + pWeightCount[vertexIndex] ] = boneIndex;
					pWeightCount[vertexIndex]++;
				}
			}
		}

		delete [] pWeightCount;
	}

	// scale mesh if necessary
	m_fScaledBy = 1;
	if ( scaleMode == 0 )
	{
		// scale to specified height
		if ( height > 0 && maxHeight > minHeight )
		{
			m_fScaledBy = height / (maxHeight-minHeight);
			for ( uint32_t i = 0; i < pMesh->mNumVertices*3; i++ )
			{
				pV[ i ] *= m_fScaledBy;
			}
		}
	}
	else if ( scaleMode == 1 )
	{
		// use height as a scale factor
		if ( height != 0 )
		{
			m_fScaledBy = height;
			for ( uint32_t i = 0; i < pMesh->mNumVertices*3; i++ )
			{
				pV[ i ] *= m_fScaledBy;
			}
		}
	}

	// load indices into AGK data
	m_iNumRawIndices = pMesh->mNumFaces*3;
	m_pRawIndices = new uint32_t[ m_iNumRawIndices ];

	for ( uint32_t i = 0; i < pMesh->mNumFaces; i++ )
	{
		m_pRawIndices[ i*3 + 0 ] = pMesh->mFaces[ i ].mIndices[ 0 ];
		m_pRawIndices[ i*3 + 1 ] = pMesh->mFaces[ i ].mIndices[ 1 ];
		m_pRawIndices[ i*3 + 2 ] = pMesh->mFaces[ i ].mIndices[ 2 ];
	}

	ProcessVertexData();
}

void cMesh::CreateFromObj( int lines, uString *sLines, float height, const char *szFilename )
{
	ClearAttribs();

	m_iFlags |= AGK_MESH_VISIBLE | AGK_MESH_COLLISION;

	uint32_t numPositions = 0;
	uint32_t numNormals = 0;
	uint32_t numTexCoords = 0;
	bool bTexCoords2 = false;
	uint32_t numIndices = 0;

	cHashedList<int> cVertexCount;
	uString token;

	// first pass count vertex and face data
	for ( int l = 0; l < lines; l++ )
	{
		uString *pLine = sLines + l;
		pLine->Trim( "\r\n " );

		if ( strncmp( pLine->GetStr(), "v ", 2 ) == 0 )
		{
			numPositions++;
		}
		else if ( strncmp( pLine->GetStr(), "vn ", 3 ) == 0 )
		{
			numNormals++;
		}
		else if ( strncmp( pLine->GetStr(), "vt ", 3 ) == 0 )
		{
			numTexCoords++;
			if ( !bTexCoords2 )
			{
				int count = pLine->CountTokens( " " );
				if ( count >= 5 ) bTexCoords2 = true;
			}
		}
		else if ( strncmp( pLine->GetStr(), "f ", 2 ) == 0 )
		{
			int count = pLine->CountTokens( " " );
			if ( count < 4 ) continue;

			// faces can have more than 3 vertices per face, need to split these later so account for the extra
			numIndices += 3;
			if ( count-1 > 3 ) 
			{
				int extra = (count-1) - 3;
				numIndices += extra*3;
			}

			// count unique vertex pairs
			for ( int i = 2; i <= count; i++ )
			{
				pLine->GetToken( " ", i, token );
				if ( token.GetLength() > 0 )
				{
					int value = cVertexCount.GetItem( token.GetStr() );
					if ( !value ) 
					{
						cVertexCount.AddItem( 1, token.GetStr() );
					}
				}
			}
		}
	}

	// vertices must have position
	if ( numPositions == 0 ) 
	{
		uString info;
		info.Format( "Failed to load object \"%s\", no vertex position data found", szFilename );
		agk::Warning( info );
		delete [] sLines;
		return;
	}

	if ( cVertexCount.GetCount() == 0 ) 
	{
		uString info;
		info.Format( "Failed to load object \"%s\", no polygon data found", szFilename );
		agk::Warning( info );
		delete [] sLines;
		return;
	}

	float *pV = 0;		float *pV2 = 0;
	float *pVT0 = 0;	float *pVT02 = 0;
	float *pVT1 = 0;	float *pVT12 = 0;
	float *pVN = 0;		float *pVN2 = 0;

	m_iNumAttribs = 1;
	m_iNumRawVertices = cVertexCount.GetCount();

	pV = new float[ numPositions*3 ];
	pV2 = new float[ m_iNumRawVertices*3 ];

	if ( numTexCoords ) 
	{
		pVT0 = new float[ numTexCoords*2 ];
		pVT02 = new float[ m_iNumRawVertices*2 ];
		m_iNumAttribs++;
	}
	if ( bTexCoords2 ) 
	{
		pVT1 = new float[ numTexCoords*2 ];
		pVT12 = new float[ m_iNumRawVertices*2 ];
		m_iNumAttribs++;
	}
	if ( numNormals ) 
	{
		pVN = new float[ numNormals*3 ];
		pVN2 = new float[ m_iNumRawVertices*3 ];
		m_iNumAttribs++;
	}

	m_pVertexAttribs = new AGKVertexAttrib[ m_iNumAttribs ];

	AGKVertexAttrib *pPositions = &m_pVertexAttribs[ 0 ];
	pPositions->m_iComponents = 3;
	pPositions->m_iType = 0;
	pPositions->m_szName = new char[ 9 ]; strcpy( pPositions->m_szName, "position" );
	pPositions->m_pData = (void*) pV2;
	m_iPosAttrib = 0;
	
	uint32_t currAttrib = 1;


	if ( pVN )
	{
		m_iNormAttrib = currAttrib;
		AGKVertexAttrib *pNormals = &m_pVertexAttribs[ currAttrib++ ];
		pNormals->m_iComponents = 3;
		pNormals->m_iType = 0;
		pNormals->m_szName = new char[ 7 ]; strcpy( pNormals->m_szName, "normal" );
		pNormals->m_pData = (void*) pVN2;
	}

	if ( pVT0 )
	{
		m_iUVAttrib = currAttrib;
		AGKVertexAttrib *pTexCoords = &m_pVertexAttribs[ currAttrib++ ];
		pTexCoords->m_iComponents = 2;
		pTexCoords->m_iType = 0;
		pTexCoords->m_szName = new char[ 3 ]; strcpy( pTexCoords->m_szName, "uv" );
		pTexCoords->m_pData = (void*) pVT02;
	}
	if ( pVT1 )
	{
		m_iUV1Attrib = currAttrib;
		AGKVertexAttrib *pTexCoords = &m_pVertexAttribs[ currAttrib++ ];
		pTexCoords->m_iComponents = 2;
		pTexCoords->m_iType = 0;
		pTexCoords->m_szName = new char[ 4 ]; strcpy( pTexCoords->m_szName, "uv1" );
		pTexCoords->m_pData = (void*) pVT12;
	}

	uint32_t iVCount = 0;
	uint32_t iVTCount = 0;
	uint32_t iVNCount = 0;

	float maxHeight = -1000000000;
	float minHeight = 1000000000;
	
	// second pass, load the vertex data
	for ( int l = 0; l < lines; l++ )
	{
		uString *pLine = sLines + l;

		if ( strncmp( pLine->GetStr(), "v ", 2 ) == 0 )
		{
			int count = pLine->CountTokens( " " );
			if ( count > 4 ) count = 4;

			for ( int i = 2; i <= count; i++ )
			{
				pLine->GetToken( " ", i, token );
				if ( token.GetLength() > 0 )
				{
					float value = token.ToFloat();
					pV[ iVCount*3 + (i-2) ] = value;
					if ( i == 3 )
					{
						if ( value > maxHeight ) maxHeight = value;
						if ( value < minHeight ) minHeight = value;
					}
				}
			}
			iVCount++;
		}
		else if ( strncmp( pLine->GetStr(), "vn ", 3 ) == 0 )
		{
			int count = pLine->CountTokens( " " );
			if ( count > 4 ) count = 4;

			for ( int i = 2; i <= count; i++ )
			{
				pLine->GetToken( " ", i, token );
				if ( token.GetLength() > 0 )
				{
					pVN[ iVNCount*3 + (i-2) ] = token.ToFloat();
				}
			}
			iVNCount++;
		}
		else if ( strncmp( pLine->GetStr(), "vt ", 3 ) == 0 )
		{
			int count = pLine->CountTokens( " " );
			if ( count > 5 ) count = 5;
			if ( count == 4 ) count = 3; // must account for 3 uv values used by some exporters

			for ( int i = 2; i <= count; i++ )
			{
				pLine->GetToken( " ", i, token );
				if ( token.GetLength() > 0 )
				{
					if ( i>=4 )
						pVT1[ iVTCount*2 + (i-4) ] = token.ToFloat();
					else
						pVT0[ iVTCount*2 + (i-2) ] = token.ToFloat();
				}
			}
			iVTCount++;
		}
	}

	// adjust model size to match height
	if ( height > 0 && maxHeight > minHeight )
	{
		float scale = height / (maxHeight-minHeight);
		for ( uint32_t i = 0; i < iVCount*3; i++ )
		{
			pV[ i ] *= scale;
		}
	}

	m_iNumRawIndices = numIndices;
	m_pRawIndices = new uint32_t[ numIndices ];
		
	uint32_t numVertices = 0;
	numIndices = 0;

	cVertexCount.ClearAll();

	// third pass load polygon data
	for ( int l = 0; l < lines; l++ )
	{
		uString *pLine = sLines + l;
		
		if ( strncmp( pLine->GetStr(), "f ", 2 ) == 0 )
		{
			int count = pLine->CountTokens( " " );
			if ( count < 4 ) continue;

			int firstIndex = numIndices;

			for ( int i = 2; i <= count; i++ )
			{
				pLine->GetToken( " ", i, token );
				if ( token.GetLength() == 0 ) 
				{
					uString info;
					info.Format( "Failed to load object \"%s\", unexpected blank token in face list", szFilename );
					agk::Warning( info );
					return;
				}

				if ( i > 4 )
				{
					m_pRawIndices[ numIndices ] = m_pRawIndices[ firstIndex ];
					numIndices++;
					m_pRawIndices[ numIndices ] = m_pRawIndices[ numIndices-2  ];
					numIndices++;
				}

				// check for shared vertex that already exists
				int iInt = cVertexCount.GetItem( token.GetStr() );
				if ( iInt ) m_pRawIndices[ numIndices ] = iInt - 1;
				else
				{
					// add new vertex
					uString token2;
					token.GetToken( "/", 1, token2 );
					uint32_t pos = token2.ToInt()-1;
					if ( pos > iVCount )
					{
						uString info;
						info.Format( "Failed to load object \"%s\", position index out of range", szFilename );
						agk::Warning( info );
						return;
					}

					// position
					pV2[ numVertices*3 + 0 ] = pV[ pos*3 + 0 ];
					pV2[ numVertices*3 + 1 ] = pV[ pos*3 + 1 ];
					pV2[ numVertices*3 + 2 ] = pV[ pos*3 + 2 ] * -1;

					int elements = token.CountTokens( "/" );
					if ( elements > 1 )
					{
						if ( token.FindStr( "//" ) == -1 )
						{
							// texcoord
							token.GetToken( "/", 2, token2 );
							uint32_t tex = token2.ToInt()-1;
							if ( tex > iVTCount )
							{
								uString info;
								info.Format( "Failed to load object \"%s\", texture coordinate index out of range", szFilename );
								agk::Warning( info );
								return;
							}
							
							pVT02[ numVertices*2 + 0 ] = pVT0[ tex*2 + 0 ];
							pVT02[ numVertices*2 + 1 ] = 1 - pVT0[ tex*2 + 1 ];
							if ( pVT1!=NULL )
							{
								pVT12[ numVertices*2 + 0 ] = pVT1[ tex*2 + 0 ];
								pVT12[ numVertices*2 + 1 ] = 1 - pVT1[ tex*2 + 1 ];
							}

							if ( elements > 2 )
							{
								// normal
								token.GetToken( "/", 3, token2 );
								uint32_t norm = token2.ToInt()-1;
								if ( norm > iVNCount )
								{
									uString info;
									info.Format( "Failed to load object \"%s\", normal index out of range", szFilename );
									agk::Warning( info );
									return;
								}
								
								float nx = pVN[ norm*3 + 0 ];
								float ny = pVN[ norm*3 + 1 ];
								float nz = pVN[ norm*3 + 2 ] * -1;

								float length = sqrt(nx*nx + ny*ny + nz*nz);
								if ( length > 0.00001f ) length = 1 / length;
								else 
								{
									ny = 1;
									length = 1;
								}

								pVN2[ numVertices*3 + 0 ] = nx * length;
								pVN2[ numVertices*3 + 1 ] = ny * length;
								pVN2[ numVertices*3 + 2 ] = nz * length;
							}
						}
						else
						{
							// normal
							token.GetToken( "/", 2, token2 );
							uint32_t norm = token2.ToInt()-1;
							if ( norm > iVNCount )
							{
								uString info;
								info.Format( "Failed to load object \"%s\", normal index out of range", szFilename );
								agk::Warning( info );
								return;
							}

							float nx = pVN[ norm*3 + 0 ];
							float ny = pVN[ norm*3 + 1 ];
							float nz = pVN[ norm*3 + 2 ] * -1;

							float length = sqrt(nx*nx + ny*ny + nz*nz);
							if ( length > 0.00001f ) length = 1 / length;
							else 
							{
								ny = 1;
								length = 1;
							}

							pVN2[ numVertices*3 + 0 ] = nx * length;
							pVN2[ numVertices*3 + 1 ] = ny * length;
							pVN2[ numVertices*3 + 2 ] = nz * length;
						}
					}

					m_pRawIndices[ numIndices ] = numVertices;
                    int index = numVertices + 1;
					cVertexCount.AddItem( index, token.GetStr() );
					numVertices++;
				}

				numIndices++;
			} // end face token loop
		}
	}

	if ( pV ) delete [] pV;
	if ( pVN ) delete [] pVN;
	if ( pVT0 ) delete [] pVT0;
	if ( pVT1 ) delete [] pVT1;

	cVertexCount.ClearAll();

	ProcessVertexData();
}

void cMesh::GetVerticesFromMemblock( uint32_t &memSize, unsigned char **pMemData )
{
	if ( !pMemData ) return;

	uint32_t size = 6*4; // header
	uint32_t vertexSize = 0;

	for ( uint32_t i = 0; i < m_iNumAttribs; ++i )
	{
		size += 4; // four 1 byte values
		uint32_t length = (uint32_t) strlen(m_pVertexAttribs[ i ].m_szName); // ignore the null terminator, it cancels with a -1 in the algorithm
		length /= 4;
		length = (length+1) * 4; // string length rounded up to nearest multiple of 4
		if ( length > 252 ) length = 252;
		size += length;

		if ( m_pVertexAttribs[ i ].m_iType == 1 ) vertexSize += 4;
		else vertexSize += 4*m_pVertexAttribs[i].m_iComponents;
	}

	uint32_t vertexOffset = size;

	size += m_iNumRawVertices * vertexSize;

	uint32_t indexOffset = size;
	if ( m_iNumRawIndices == 0 ) indexOffset = 0;
	size += m_iNumRawIndices * 4;

	memSize = size;
	*pMemData = new unsigned char[ memSize ];
	float *pMemDataFloat = (float*)(*pMemData);
	int *pMemDataInt = (int*)(*pMemData);
	unsigned char *pMemDataByte = (unsigned char*)(*pMemData);

	pMemDataInt[ 0 ] = m_iNumRawVertices;
	pMemDataInt[ 1 ] = m_iNumRawIndices;
	pMemDataInt[ 2 ] = m_iNumAttribs;
	pMemDataInt[ 3 ] = vertexSize;
	pMemDataInt[ 4 ] = vertexOffset;
	pMemDataInt[ 5 ] = indexOffset;

	uint32_t offset = 24;
	for ( uint32_t i = 0; i < m_iNumAttribs; ++i )
	{
		pMemDataByte[ offset++ ] = m_pVertexAttribs[i].m_iType;
		pMemDataByte[ offset++ ] = m_pVertexAttribs[i].m_iComponents;
		pMemDataByte[ offset++ ] = m_pVertexAttribs[i].m_iNormalize;
		
		uint32_t nameLength = (uint32_t) strlen(m_pVertexAttribs[ i ].m_szName); // ignore the null terminator, it cancels with a -1 in the algorithm
		uint32_t length = nameLength / 4; 
		length = (length+1) * 4; // string length rounded up to nearest multiple of 4
		if ( length > 252 ) length = 252;
		
		pMemDataByte[ offset++ ] = length;
		memset( &(pMemDataByte[ offset ]), 0, length );
		memcpy( &(pMemDataByte[ offset ]), m_pVertexAttribs[ i ].m_szName, nameLength+1 );
		
		offset += length;
	}

	uint32_t offsetFloat = offset/4;
	for ( uint32_t v = 0; v < m_iNumRawVertices; ++v )
	{
		for ( uint32_t a = 0; a < m_iNumAttribs; ++a )
		{
			if ( m_pVertexAttribs[a].m_iType == 1 )
			{
				pMemDataInt[ offsetFloat++ ] = ((int*)(m_pVertexAttribs[a].m_pData))[ v ];
			}
			else
			{
				for ( uint32_t c = 0; c < m_pVertexAttribs[a].m_iComponents; c++ )
				{
					pMemDataFloat[ offsetFloat++ ] = ((float*)(m_pVertexAttribs[a].m_pData))[ v*m_pVertexAttribs[a].m_iComponents + c ];
				}
			}
		}
	}

	for ( uint32_t i = 0; i < m_iNumRawIndices; ++i ) 
	{
		pMemDataInt[ offsetFloat++ ] = ((int*)m_pRawIndices)[ i ];
	}
}

void cMesh::SetVerticesFromMemblock( uint32_t memSize, unsigned char *pMemData )
{
	if ( !pMemData ) return;
	float *pMemDataFloat = (float*) pMemData;
	int *pMemDataInt = (int*) pMemData;

	// if the structure and num vertices hasn't changed then shortcuts can be made
	bool bChangedStructure = false;

	if ( pMemDataInt[ 2 ] != m_iNumAttribs ) 
	{
		bChangedStructure = true;
	}

	m_iFlags &= ~AGK_MESH_HAS_BONES;

	// further structure checks and vertex offset calculation
	uint32_t offset = 24;
	uint32_t vertexSize = 0;
	for ( int i = 0; i < pMemDataInt[2]; ++i )
	{
		if ( offset+8 > memSize ) 
		{
			agk::Error("Failed to set mesh from memblock data, memblock is too small for the data it claims to contain");
			return;
		}

		if ( pMemData[offset + 0] > 1 ) 
		{
			agk::Error("Failed to set mesh from memblock data, vertex attribute data type must be 0 or 1");
			return;
		}

		if ( pMemData[offset + 1] < 1 || pMemData[offset + 1] > 4 ) 
		{
			agk::Error("Failed to set mesh from memblock data, vertex attribute component count must be between 1 and 4");
			return;
		}

		if ( !bChangedStructure )
		{
			if ( pMemData[ offset + 0 ] != m_pVertexAttribs[i].m_iType
			  || pMemData[ offset + 1 ] != m_pVertexAttribs[i].m_iComponents ) 
			{
				bChangedStructure = true;
			}
		}

		if ( pMemData[offset + 0] == 1 ) vertexSize += 4;
		else vertexSize += pMemData[ offset + 1 ] * 4;

		uint32_t length = pMemData[ offset + 3 ];
		if ( length % 4 != 0 )
		{
			agk::Error("Failed to set mesh from memblock data, vertex attribute name length must be a multiple of 4");
			return;
		}

		int length2 = length;
		if ( length2 > 11 ) length2 = 11;
		if ( strncmp( ((char*)pMemData)+offset+4, "boneindices", length2 ) == 0 ) m_iFlags |= AGK_MESH_HAS_BONES;

		offset += 4;
		offset += length;
	}

	uint32_t vertexOffset = offset;
	uint32_t indexOffset = vertexOffset + pMemDataInt[0]*vertexSize;
	uint32_t correctSize = indexOffset + pMemDataInt[1]*4;

	if ( correctSize > memSize )
	{
		agk::Error("Failed to set mesh from memblock data, memblock is too small for the data it claims to contain");
		return;
	}

	if ( bChangedStructure )
	{
		// delete everything and start again
		if ( m_pVertexAttribs ) delete [] m_pVertexAttribs;
		
		m_iPosAttrib = -1;
		m_iNormAttrib = -1;
		m_iUVAttrib = -1;
		m_iUV1Attrib = -1;
		m_iTangentAttrib = -1;
		m_iBiNormAttrib = -1;
		m_iColorAttrib = -1;
		m_iBoneIndicesAttrib = -1;
		m_iBoneWeightsAttrib = -1;
		// bone flag has already been updated

		m_cOtherAttributeNames.ClearAll();

		m_iNumRawVertices = pMemDataInt[ 0 ];
		m_iNumAttribs = pMemDataInt[ 2 ];
		m_pVertexAttribs = new AGKVertexAttrib[ m_iNumAttribs ];

		offset = 24;
		for ( uint32_t i = 0; i < m_iNumAttribs; ++i )
		{
			m_pVertexAttribs[ i ].m_iType = pMemData[ offset + 0 ];
			m_pVertexAttribs[ i ].m_iComponents = pMemData[ offset + 1 ];
			m_pVertexAttribs[ i ].m_iNormalize = (pMemData[ offset + 2 ] != 0) ? 1 : 0;
			uint32_t length = pMemData[ offset + 3 ];
			m_pVertexAttribs[ i ].m_szName = new char[ length+1 ];
			memcpy( m_pVertexAttribs[ i ].m_szName, ((char*)pMemData)+offset+4, length );
			m_pVertexAttribs[ i ].m_szName[ length ] = 0;
			if ( m_pVertexAttribs[ i ].m_iType == 1 ) 
			{
				m_pVertexAttribs[ i ].m_pData = new unsigned char[ m_iNumRawVertices*4 ];
			}
			else 
			{
				m_pVertexAttribs[ i ].m_pData = new float[ m_iNumRawVertices*m_pVertexAttribs[i].m_iComponents ];
			}

			offset = offset + 4 + length;

			SetAttribNameIndex( m_pVertexAttribs[ i ].m_szName, i );
		}
	}

	// if num vertices changed then recreate vertex arrays
	if ( pMemDataInt[ 0 ] != m_iNumRawVertices )
	{
		bChangedStructure = true;
		m_iNumRawVertices = pMemDataInt[ 0 ];
		for ( unsigned char i = 0; i < m_iNumAttribs; i++ )
		{
			m_pVertexAttribs[ i ].ClearData();

			if ( m_pVertexAttribs[ i ].m_iType == 0 ) 
			{
				m_pVertexAttribs[ i ].m_pData = new float[ m_iNumRawVertices*m_pVertexAttribs[i].m_iComponents ];
			}
			else if ( m_pVertexAttribs[ i ].m_iType == 1 ) 
			{
				m_pVertexAttribs[ i ].m_pData = new unsigned char[ m_iNumRawVertices*4 ];
			}
		}
	}

	// if number of indices has changed then recreate index array
	if ( pMemDataInt[ 1 ] != m_iNumRawIndices )
	{
		bChangedStructure = true;
		if ( m_pRawIndices ) delete [] m_pRawIndices;
		m_iNumRawIndices = pMemDataInt[ 1 ];
		m_pRawIndices = new uint32_t[ m_iNumRawIndices ];
	}

	// at this point the mesh arrays are guaranteed to line up with the memblock structure

	// copy the vertex data
	offset = vertexOffset / 4;
	for ( uint32_t v = 0; v < m_iNumRawVertices; v++ )
	{
		for ( uint32_t a = 0; a < m_iNumAttribs; a++ )
		{
			if ( m_pVertexAttribs[ a ].m_iType == 1 )
			{
				((int*)(m_pVertexAttribs[ a ].m_pData))[ v ] = pMemDataInt[ offset ];
				offset++;
			}
			else
			{
				for ( uint32_t c = 0; c < m_pVertexAttribs[ a ].m_iComponents; c++ )
				{
					((float*)(m_pVertexAttribs[ a ].m_pData))[ v*m_pVertexAttribs[a].m_iComponents + c ] = pMemDataFloat[ offset ];
					offset++;
				}
			}
		}
	}

	// copy the index data
	offset = indexOffset / 4;
	for ( uint32_t i = 0; i < m_iNumRawIndices; i++ )
	{
		m_pRawIndices[ i ] = pMemDataInt[ offset+i ];
	}

	ProcessVertexData();
}

void cMesh::TranslateMesh( float x, float y, float z, int update )
{
	if ( m_iPosAttrib < 0 ) return;

	float* pV = (float*) m_pVertexAttribs[ m_iPosAttrib ].m_pData;

	for ( uint32_t j = 0; j < m_iNumRawVertices; j++ )
	{
		pV[ j*3 + 0 ] += x;
		pV[ j*3 + 1 ] += y;
		pV[ j*3 + 2 ] += z;
	}

	if ( update ) ProcessVertexData();
}

void cMesh::RotateMesh( float w, float x, float y, float z, int update )
{
	AGKQuaternion q( w,x,y,z );

	bool bFound = false;
	for ( uint32_t i = 0; i < m_iNumAttribs; i++ )
	{
		if ( i == m_iPosAttrib || i == m_iNormAttrib || i == m_iTangentAttrib || i == m_iBiNormAttrib )
		{
			float* pV = (float*) m_pVertexAttribs[ i ].m_pData;

			for ( uint32_t j = 0; j < m_iNumRawVertices; j++ )
			{
				AGKVector v( pV[j*3+0], pV[j*3+1], pV[j*3+2] );

				v = q * v;
				
				pV[ j*3 + 0 ] = v.x;
				pV[ j*3 + 1 ] = v.y;
				pV[ j*3 + 2 ] = v.z;
			}

			bFound = true;
		}
	}

	if ( bFound && update != 0 ) ProcessVertexData();
}

void cMesh::ScaleMesh( float x, float y, float z, int update )
{
	bool bFound = false;
	if ( m_iPosAttrib >= 0 )
	{
		bFound = true;

		float* pV = (float*) m_pVertexAttribs[ m_iPosAttrib ].m_pData;
		for ( uint32_t j = 0; j < m_iNumRawVertices; j++ )
		{
			pV[ j*3 + 0 ] *= x;
			pV[ j*3 + 1 ] *= y;
			pV[ j*3 + 2 ] *= z;
		}
	}

	for ( uint32_t i = 0; i < m_iNumAttribs; i++ )
	{
		if ( i == m_iNormAttrib || i == m_iTangentAttrib || i == m_iBiNormAttrib )
		{
			float diff1 = agk::Abs( x - y );
			float diff2 = agk::Abs( y - z );
			if ( diff1 < 0.000001f && diff2 < 0.000001f ) continue; // only modify normals if the scale is non-uniform

			float* pV = (float*) m_pVertexAttribs[ i ].m_pData;

			for ( uint32_t j = 0; j < m_iNumRawVertices; j++ )
			{
				if ( x == 0 ) 
				{
					pV[ j*3 + 0 ] = 1;
					pV[ j*3 + 1 ] = 0;
					pV[ j*3 + 2 ] = 0;
				}
				else if ( y == 0 ) 
				{
					pV[ j*3 + 0 ] = 0;
					pV[ j*3 + 1 ] = 1;
					pV[ j*3 + 2 ] = 0;
				}
				else if ( z == 0 ) 
				{
					pV[ j*3 + 0 ] = 0;
					pV[ j*3 + 1 ] = 0;
					pV[ j*3 + 2 ] = 1;
				}
				else
				{
					pV[ j*3 + 0 ] /= x;
					pV[ j*3 + 1 ] /= y;
					pV[ j*3 + 2 ] /= z;

					float length = pV[j*3+0]*pV[j*3+0] + pV[j*3+1]*pV[j*3+1] + pV[j*3+2]*pV[j*3+2];
					if ( length > 0 ) length = 1 / agk::Sqrt( length );
					pV[ j*3 + 0 ] *= length;
					pV[ j*3 + 1 ] *= length;
					pV[ j*3 + 2 ] *= length;
				}
			}

			bFound = true;
		}
	}

	if ( bFound && update != 0 ) ProcessVertexData();
}

void cMesh::GetBoundingBoxForBone( int boneIndex, Bone3D *pBone, Box* pBounds )
{
	if ( !HasBones() ) return;
	if ( m_iPosAttrib < 0 || m_iBoneIndicesAttrib < 0 || m_iBoneWeightsAttrib < 0 ) return;

	// find bone attributes
	AGKVertexAttrib *pPos = &m_pVertexAttribs[ m_iPosAttrib ];
	AGKVertexAttrib *pIndices = &m_pVertexAttribs[ m_iBoneIndicesAttrib ];
	AGKVertexAttrib *pWeights = &m_pVertexAttribs[ m_iBoneWeightsAttrib ];
	
	float minX=pBounds->minbx(), minY=pBounds->minby(), minZ=pBounds->minbz();
	float maxX=pBounds->maxbx(), maxY=pBounds->maxby(), maxZ=pBounds->maxbz();

	unsigned char *pIndexData = (unsigned char*) (pIndices->m_pData);
	float *pWeightData = (float*) (pWeights->m_pData);
	float *pPosData = (float*) (pPos->m_pData);

	int found = 0;
	for ( uint32_t i = 0; i < m_iNumRawVertices; i++ )
	{
		for ( int j = 0; j < 4; j++ )
		{
			if ( pIndexData[ i*4 + j ] == boneIndex && pWeightData[ i*4 + j ] > 0.3f )
			{
				// transform vertex into bone space
				AGKVector pos;
				pos.x = pPosData[ i*3 + 0 ];
				pos.y = pPosData[ i*3 + 1 ];
				pos.z = pPosData[ i*3 + 2 ];

				pos = pBone->m_offsetRotation * pos;
				pos = pos + pBone->m_offsetPosition;

				if ( pos.x < minX ) minX = pos.x;
				if ( pos.x > maxX ) maxX = pos.x;
				
				if ( pos.y < minY ) minY = pos.y;
				if ( pos.y > maxY ) maxY = pos.y;

				if ( pos.z < minZ ) minZ = pos.z;
				if ( pos.z > maxZ ) maxZ = pos.z;
				found = 1;
			}
		}
	}

	if ( found ) pBounds->set( minX, minY, minZ, maxX, maxY, maxZ );
	else pBounds->set( 0,0,0,0,0,0 );
}

Face* cMesh::GetFaceList( Face **pLast )
{
	// find position attribute
	AGKVertexAttrib *pPos = 0;
	if ( m_iPosAttrib >= 0 ) pPos = &m_pVertexAttribs[ m_iPosAttrib ];
	
	if ( !pPos || !pPos->m_pData ) 
	{
		agk::Warning( "No vertex position attribute found to build collision data" );
		return 0;
	}

	if ( pPos->m_iComponents < 3 ) 
	{
		agk::Warning( "Not enough vertex position components to build collision data" );
		return 0;
	}

	AGKVector p1, p2, p3;
	uint32_t index;
	Face* pFaces = 0;

	if ( m_iNumRawIndices == 0 )
	{
		float *pData = (float*) pPos->m_pData;

		for ( uint32_t i = 0; i < m_iNumRawVertices/3; i++ )
		{
			p1.Set( pData[ i*9 + 0 ], pData[ i*9 + 1 ], pData[ i*9 + 2 ] );
			p2.Set( pData[ i*9 + 3 ], pData[ i*9 + 4 ], pData[ i*9 + 5 ] );
			p3.Set( pData[ i*9 + 6 ], pData[ i*9 + 7 ], pData[ i*9 + 8 ] );

			Face* aFace = new Face( );
			if ( !aFace->MakeFace( i, &p1, &p2, &p3 ) ) 
			{ 
				delete aFace; 
				continue; 
			}
	        
			if ( pFaces == 0 && pLast ) *pLast = aFace;
			aFace->nextFace = pFaces;
			pFaces = aFace;
		}
	}
	else
	{
		float *pData = (float*) pPos->m_pData;

		if ( m_iPrimitiveType == AGK_PRIMITIVE_TRIANGLES )
		{
			for ( uint32_t i = 0; i < m_iNumRawIndices/3; i++ )
			{
				index = m_pRawIndices[ i*3 + 0 ];
				p1.Set( pData[ index*3 + 0 ], pData[ index*3 + 1 ], pData[ index*3 + 2 ] );

				index = m_pRawIndices[ i*3 + 1 ];
				p2.Set( pData[ index*3 + 0 ], pData[ index*3 + 1 ], pData[ index*3 + 2 ] );

				index = m_pRawIndices[ i*3 + 2 ];
				p3.Set( pData[ index*3 + 0 ], pData[ index*3 + 1 ], pData[ index*3 + 2 ] );

				Face* aFace = new Face( );
				if ( !aFace->MakeFace( i, &p1, &p2, &p3 ) ) 
				{ 
					delete aFace; 
					continue; 
				}
		        
				if ( pFaces == 0 && pLast ) *pLast = aFace;
				aFace->nextFace = pFaces;
				pFaces = aFace;
			}
		}
		else if ( m_iPrimitiveType == AGK_PRIMITIVE_TRIANGLE_STRIP )
		{
			int reverse = 0;
			for ( uint32_t i = 2; i < m_iNumRawIndices; i++ )
			{
				reverse = 1-reverse; // every other triangle needs its winding reversed

				index = m_pRawIndices[ i - 2 ];
				p1.Set( pData[ index*3 + 0 ], pData[ index*3 + 1 ], pData[ index*3 + 2 ] );

				index = m_pRawIndices[ i - reverse ];
				p2.Set( pData[ index*3 + 0 ], pData[ index*3 + 1 ], pData[ index*3 + 2 ] );

				index = m_pRawIndices[ i - (1-reverse) ];
				p3.Set( pData[ index*3 + 0 ], pData[ index*3 + 1 ], pData[ index*3 + 2 ] );

				Face* aFace = new Face( );
				if ( !aFace->MakeFace( i, &p1, &p2, &p3 ) ) 
				{ 
					delete aFace; 
					continue; 
				}
		        
				if ( pFaces == 0 && pLast ) *pLast = aFace;
				aFace->nextFace = pFaces;
				pFaces = aFace;
			}
		}
	}

	return pFaces;
}

void cMesh::SetImage( cImage *pImage, uint32_t stage )
{
	if ( stage >= AGK_MAX_TEXTURE_STAGES ) return;
	if ( stage == 1 ) m_iFlags &= ~AGK_MESH_HAS_LIGHTMAP;
	if ( stage == 2 ) m_iFlags &= ~AGK_MESH_HAS_NORMALMAP;
		
	m_shaderImages.SetItem( stage, pImage );
}

void cMesh::SetUVOffset( uint32_t stage, float offsetU, float offsetV )
{
	if ( stage >= AGK_MAX_TEXTURE_STAGES ) return;

	UVOffsetScale *pItem = m_uvOffsetScales.GetItem( stage );
	if ( !pItem )
	{
		pItem = new UVOffsetScale();
		pItem->scaleU = 1;
		pItem->scaleV = 1;
		m_uvOffsetScales.SetItem( stage, pItem );
	}

	pItem->offsetU = offsetU;
	pItem->offsetV = offsetV;
	m_iFlags |= AGK_MESH_UV_SCALES_UPDATED;
}

void cMesh::SetUVScale( uint32_t stage, float scaleU, float scaleV )
{
	if ( stage >= AGK_MAX_TEXTURE_STAGES ) return;

	UVOffsetScale *pItem = m_uvOffsetScales.GetItem( stage );
	if ( !pItem )
	{
		pItem = new UVOffsetScale();
		pItem->offsetU = 0;
		pItem->offsetV = 0;
		m_uvOffsetScales.SetItem( stage, pItem );
	}

	pItem->scaleU = scaleU;
	pItem->scaleV = scaleV;
	m_iFlags |= AGK_MESH_UV_SCALES_UPDATED;
}

void cMesh::SetLightMap( cImage *pImage )
{
	m_iFlags |= AGK_MESH_HAS_LIGHTMAP;
	m_shaderImages.SetItem( 1, pImage );
}

void cMesh::SetNormalMap( cImage *pImage )
{
	m_iFlags |= AGK_MESH_HAS_NORMALMAP;
	m_shaderImages.SetItem( 2, pImage );
}

void cMesh::SetNormalMapScale( float scaleU, float scaleV )
{
	m_fNormalScaleU = scaleU;
	m_fNormalScaleV = scaleV;
}

void cMesh::SetShader( AGKShader *pShader ) 
{ 
	if ( pShader ) 
	{
		if ( m_pOrigShader != pShader )
		{
			if ( m_pOrigShader ) m_pOrigShader->RemoveRef();
			pShader->AddRef();
			m_pOrigShader = pShader;
		}
	}
	else 
	{
		// AGK will generate a shader to display this object
		m_pOrigShader = 0;
	}
}

int cMesh::CompareLightItem( const void* a, const void* b )
{
	lightItem* light1 = (lightItem*)a;
	lightItem* light2 = (lightItem*)b;

	if ( light1->dist == light2->dist ) return 0;
	else if ( light1->dist < light2->dist ) return -1;
	else return 1;
}

void cMesh::CheckLights()
{
	if ( m_pObject->GetLightMode() == 0 ) 
	{
		m_iNumVSLights = 0;
		m_iNumPSLights = 0;
		return;
	}

	if ( agk::m_cPointLightList.GetCount() == 0 ) 
	{
		m_iNumVSLights = 0;
		m_iNumPSLights = 0;
		return;
	}

	AGKVector pos = m_pObject->posFinal();
	AGKQuaternion rot = m_pObject->rotFinal(); rot.Invert();
	AGKVector scale = m_pObject->scaleFinal();

	float largestScale = scale.x;
	if ( scale.y > largestScale ) largestScale = scale.y;
	if ( scale.z > largestScale ) largestScale = scale.z;

	AGKPointLight **pLightShortList = new AGKPointLight*[ agk::m_cPointLightList.GetCount() ];
	lightItem *pLightDist = new lightItem[ agk::m_cPointLightList.GetCount() ];
	
	int iShortListCount = 0;
	int iVSShortListCount = 0;
	int iPSShortListCount = 0;

	AGKPointLight *pLight = agk::m_cPointLightList.GetFirst();
	while( pLight )
	{
		float radius = m_fRadius * largestScale;
		float sqrRadius = (radius+pLight->m_fRadius)*(radius+pLight->m_fRadius);
			
		float diffX = pLight->m_position.x - pos.x;
		float diffY = pLight->m_position.y - pos.y;
		float diffZ = pLight->m_position.z - pos.z;
		float sqrDist = diffX*diffX + diffY*diffY + diffZ*diffZ;

		// check bounding sphere
		if ( sqrRadius < sqrDist )
		{
			// light is too far away to affect this mesh
			pLight = agk::m_cPointLightList.GetNext();
			continue;
		}

		// transform light to object space
		AGKVector lightPos = pLight->m_position - pos;
		lightPos = rot * lightPos;

		// check bounding box
		float minx = m_BoundingBox.minbx() * scale.x;
		float miny = m_BoundingBox.minby() * scale.y;
		float minz = m_BoundingBox.minbz() * scale.z;
		float maxx = m_BoundingBox.maxbx() * scale.x;
		float maxy = m_BoundingBox.maxby() * scale.y;
		float maxz = m_BoundingBox.maxbz() * scale.z;
		    
		float sqrDist2 = 0;
		    
		// get the distance of light from the outside of the box
		if (lightPos.x > maxx) sqrDist2 = (lightPos.x - maxx)*(lightPos.x - maxx);
		else if (lightPos.x < minx) sqrDist2 = (minx - lightPos.x)*(minx - lightPos.x);
		    
		if (lightPos.y > maxy) sqrDist2 += (lightPos.y - maxy)*(lightPos.y - maxy);
		else if (lightPos.y < miny) sqrDist2 += (miny - lightPos.y)*(miny - lightPos.y);
		    
		if (lightPos.z > maxz) sqrDist2 += (lightPos.z - maxz)*(lightPos.z - maxz);
		else if (lightPos.z < minz) sqrDist2 += (minz - lightPos.z)*(minz - lightPos.z);
		    
		if ( sqrDist2 > (pLight->m_fRadius*pLight->m_fRadius) ) 
		{
			// light is too far away to affect this mesh
			pLight = agk::m_cPointLightList.GetNext();
			continue;
		}

		pLightShortList[ iShortListCount ] = pLight;
		pLightDist[ iShortListCount ].dist = sqrDist;
		pLightDist[ iShortListCount ].index = iShortListCount;
		iShortListCount++;
		if ( pLight->m_iType == 0 ) iVSShortListCount++;
		else iPSShortListCount++;

		pLight = agk::m_cPointLightList.GetNext();
	}

	// All lights in pLightShortList should affect the mesh, if we are not over the limit send them all
	// otherwise we will have to sort by distance
	m_iNumVSLights = 0;
	m_iNumPSLights = 0;
	bool bSorted = false;

	if ( iVSShortListCount > 0 && iVSShortListCount <= AGK_MAX_VERTEX_LIGHTS )
	{
		for ( int L = 0; L < iShortListCount; ++L )
		{
			if ( pLightShortList[ L ]->m_iType == 0 ) m_pVSLights[ m_iNumVSLights++ ] = pLightShortList[ L ];
		}
	}
	else
	{
		// need to sort by distance
		qsort( pLightDist, iShortListCount, sizeof(lightItem), CompareLightItem );
		bSorted = true;

		for ( int L = 0; L < iShortListCount && m_iNumVSLights < AGK_MAX_VERTEX_LIGHTS; ++L )
		{
			int index = pLightDist[ L ].index;
			if ( pLightShortList[ index ]->m_iType == 0 ) m_pVSLights[ m_iNumVSLights++ ] = pLightShortList[ index ];
		}
	}

	// do the same for pixel lights
	if ( iPSShortListCount > 0 && iPSShortListCount <= AGK_MAX_PIXEL_LIGHTS )
	{
		for ( int L = 0; L < iShortListCount; ++L )
		{
			if ( pLightShortList[ L ]->m_iType > 0 ) m_pPSLights[ m_iNumPSLights++ ] = pLightShortList[ L ];
		}
	}
	else
	{
		// need to sort by distance
		if ( !bSorted ) qsort( pLightDist, iShortListCount, sizeof(lightItem), CompareLightItem );

		int L;
		for ( L = 0; L < iShortListCount && m_iNumPSLights < AGK_MAX_PIXEL_LIGHTS; ++L )
		{
			int index = pLightDist[ L ].index;
			if ( pLightShortList[ index ]->m_iType > 0 ) m_pPSLights[ m_iNumPSLights++ ] = pLightShortList[ index ];
		}

		// add any remaining pixel lights as vertex lights if possible
		if ( m_iNumVSLights < AGK_MAX_VERTEX_LIGHTS )
		{
			for ( ; L < iShortListCount && m_iNumVSLights < AGK_MAX_VERTEX_LIGHTS; ++L )
			{
				int index = pLightDist[ L ].index;
				if ( pLightShortList[ index ]->m_iType > 0 ) m_pVSLights[ m_iNumVSLights++ ] = pLightShortList[ index ];
			}
		}
	}

	delete [] pLightShortList;
	delete [] pLightDist;
}

void cMesh::UpdateVertexLayout( AGKVertexLayout *pLayout, AGKShader *pShader )
{
	if ( !pLayout ) return;
	if ( !pShader ) return;

	int numShaderAttribs = pShader->GetNumAttributes();
	pLayout->SetNumOffsets( numShaderAttribs );
	
	pLayout->m_iPrimitiveType = m_iPrimitiveType;
	
	for( int i = 0; i < numShaderAttribs; i++ )
	{
		AGKShaderAttrib *pShaderAttrib = pShader->GetAttribute( i );
		int index = -1;
		switch( pShaderAttrib->m_iKnownName )
		{
			case AGK_SHADER_ATTRIB_NAME_UNKNOWN:
			{
				index = (int)m_cOtherAttributeNames.GetItem( pShaderAttrib->m_szName );
				index--;
				break;
			}
			case AGK_SHADER_ATTRIB_NAME_POS:	index = m_iPosAttrib; break;
			case AGK_SHADER_ATTRIB_NAME_NORM:	index = m_iNormAttrib; break;
			case AGK_SHADER_ATTRIB_NAME_UV0:	index = m_iUVAttrib; break;
			case AGK_SHADER_ATTRIB_NAME_COLOR:	index = m_iColorAttrib; break;
			case AGK_SHADER_ATTRIB_NAME_BONE_INDEX:		index = m_iBoneIndicesAttrib; break;
			case AGK_SHADER_ATTRIB_NAME_BONE_WEIGHT:	index = m_iBoneWeightsAttrib; break;
			case AGK_SHADER_ATTRIB_NAME_TANGENT:	index = m_iTangentAttrib; break;
			case AGK_SHADER_ATTRIB_NAME_BINORMAL:	index = m_iBiNormAttrib; break;
			case AGK_SHADER_ATTRIB_NAME_UV1:	index = m_iUV1Attrib; break;
		}

		if ( index >= 0 )
		{
			pLayout->m_pOffsets[ i ] = m_pVertexAttribs[ index ].m_iOffset;
			
			if ( m_pVertexAttribs[ index ].m_iComponents != pShaderAttrib->m_iComponents )
			{
				uString info;
				info.Format( "Shader \"%s\" attribute \"%s\" has a different number of components than the vertices in object %d provide, this shader may fail to display the object", pShader->GetVSFilename(), m_pVertexAttribs[ index ].m_szName, m_pObject->m_iID );
				agk::Warning( info );
			}
		}
		else
		{
			uString info;
			info.Format( "Shader \"%s\" requires vertex attributes that object %d does not provide, this shader may fail to display the object", pShader->GetVSFilename(), m_pObject->m_iID );
			agk::Warning( info );
			
			pLayout->m_pOffsets[ i ] = 0; // point this attribute at the first attribute, it won't be the right data but at least it will get something
		}
	}
}

void cMesh::CheckShader()
{
	if ( m_pOrigShader && !m_pOrigShader->IsValid() )
	{
		if ( m_pOrigShader->IsCustom() )
		{
			agk::Warning("Invalid shader was removed and replaced with a system generated one");
			m_pOrigShader->RemoveRef();
			m_pOrigShader = 0;
		}
		else
		{
			agk::Error("Internal shader error");
			return;
		}
	}

	if ( !m_pOrigShader || m_pOrigShader->IsGenerated() )
	{
		uint32_t hash = AGKShader::GetMeshShaderHash( this );
		if ( !m_pOrigShader || m_pOrigShader->GetHash() != hash )
		{
			// something changed so we need to switch shader
			AGKShader *pNewShader = AGKShader::Make3DShader( this );
			if ( !pNewShader ) 
			{
				agk::Error("Internal shader error");
				return;
			}
			else if ( pNewShader != m_pOrigShader ) 
			{
				if ( m_pOrigShader ) m_pOrigShader->RemoveRef();
				pNewShader->AddRef();
				m_pOrigShader = pNewShader;
			}
		}
	}

	if ( !m_pOrigShader ) return;

	if ( !m_pOrigShader->NeedsAdditionalCode() )
	{
		// shader doesn't need additional code, so use it directly, we might be referencing the 
		// same shader twice but as long as we remove it twice later it should be fine
		if ( m_pShader != m_pOrigShader )
		{
			if ( m_pShader ) m_pShader->RemoveRef();
			m_pOrigShader->AddRef();
			m_pShader = m_pOrigShader;

			if ( !m_pSharedVertices ) UpdateVertexLayout( &m_vertexLayout, m_pShader );
			else m_pSharedVertices->UpdateVertexLayout( &m_vertexLayout, m_pShader );
		}
	}
	else
	{
		// shader needs additional code, check if we've already done it
		uint32_t hash = AGKShader::GetFinalShaderHash( agk::m_cDirectionalLight.m_active, m_iNumVSLights, m_iNumPSLights, WantsShadows() );
		if ( !m_pShader || m_pShader->GetHash() != hash || m_pShader->GetBaseShader() != m_pOrigShader )
		{
			// need to update m_pShader
			AGKShader *pNewShader = AGKShader::MakeFinalShader( m_pOrigShader, agk::m_cDirectionalLight.m_active, m_iNumVSLights, m_iNumPSLights, WantsShadows(), HasNormalMap() );
			if ( !pNewShader )
			{
				if ( m_pOrigShader->IsCustom() )
				{
					agk::Warning("Invalid shader was removed and replaced with a system generated one");
					m_pOrigShader->SetValid( false );
					m_pOrigShader->RemoveRef();
					m_pOrigShader = 0;
					if ( m_pShader ) m_pShader->RemoveRef();
					m_pShader = 0;
				}
				else
				{
					agk::Error("Internal shader error");
					return;
				}
			}
			else if ( pNewShader != m_pShader )
			{
				if ( m_pShader ) m_pShader->RemoveRef();
				pNewShader->AddRef();
				m_pShader = pNewShader;

				if ( !m_pSharedVertices ) UpdateVertexLayout( &m_vertexLayout, m_pShader );
				else m_pSharedVertices->UpdateVertexLayout( &m_vertexLayout, m_pShader );
			}
		}
	}
}

void cMesh::Update()
{
	
}

void cMesh::UpdateUVOffsetScaleShaderVars()
{
	m_shaderVarUVOffsetScales.Expand( m_uvOffsetScales.GetHighestIndex() + 1 );

	int iHighestIndex = m_uvOffsetScales.GetHighestIndex();
	for( int i = 0; i <= iHighestIndex; i++ )
	{
		UVOffsetScale *pUV = m_uvOffsetScales.GetItem( i );
		AGKShaderConstantValue *pVar = m_shaderVarUVOffsetScales.GetItem( i );
		if ( !pUV )
		{
			if ( pVar ) 
			{
				delete pVar;
				m_shaderVarUVOffsetScales.SetItem( i, 0 );
			}
		}
		else
		{
			if ( !pVar )
			{
				pVar = new AGKShaderConstantValue();
				pVar->SetKnownName( AGK_SHADER_CONSTANT_NAME_UV_BOUNDS_0 + i );
				m_shaderVarUVOffsetScales.SetItem( i, pVar );
			}

			pVar->SetVector4( pUV->scaleU, pUV->scaleV, pUV->offsetU, pUV->offsetV );
		}
	}

	int iHighestIndex2 = m_shaderVarUVOffsetScales.GetHighestIndex();
	for( int i = iHighestIndex+1; i <= iHighestIndex2; i++ )
	{
		AGKShaderConstantValue *pVar = m_shaderVarUVOffsetScales.GetItem( i );
		if ( pVar )
		{
			delete pVar;
			m_shaderVarUVOffsetScales.SetItem( i, 0 );
		}
	}

	m_iFlags &= ~AGK_MESH_UV_SCALES_UPDATED;
}

void cMesh::SetAttribNameIndex( const char *szName, int8_t index )
{
	if ( strcmp(szName, "position") == 0 )		m_iPosAttrib = index;
	else if ( strcmp(szName, "normal") == 0 )	m_iNormAttrib = index;
	else if ( strcmp(szName, "uv") == 0 )		m_iUVAttrib = index;
	else if ( strcmp(szName, "uv1") == 0 )		m_iUV1Attrib = index;
	else if ( strcmp(szName, "tangent") == 0 )	m_iTangentAttrib = index;
	else if ( strcmp(szName, "binormal") == 0 ) m_iBiNormAttrib = index;
	else if ( strcmp(szName, "color") == 0 )	m_iColorAttrib = index;
	else if ( strcmp(szName, "boneindices") == 0 ) m_iBoneIndicesAttrib = index;
	else if ( strcmp(szName, "boneweights") == 0 ) m_iBoneWeightsAttrib = index;
	else
	{
		m_cOtherAttributeNames.AddItem( index+1, szName );
	}
}

void cMesh::Draw()
{
	if ( !m_pObject->GetVisible() ) return;
	if ( !GetVisible() ) return;

	if ( m_pObject->DoesCullToScreen() && !GetInScreen() ) return;

	CheckLights();
	CheckShader();
	if ( !m_pShader ) return;

	if ( WantsShadows() )
	{
		if ( agk::GetShadowMappingMode() > 0 ) 
		{
			m_shaderImages.SetItem( 7, agk::m_pShadowMap );
		}
		if ( agk::GetShadowMappingMode() == 3 ) 
		{
			m_shaderImages.SetItem( 6, agk::m_pShadowMap2 );
			m_shaderImages.SetItem( 5, agk::m_pShadowMap3 );
			m_shaderImages.SetItem( 4, agk::m_pShadowMap4 );
		}
	}

	if ( HasNormalMap() )
	{
		if ( !m_pShaderVarNormalScale ) 
		{
			m_pShaderVarNormalScale = new AGKShaderConstantValue();
			m_pShaderVarNormalScale->SetKnownName( AGK_SHADER_CONSTANT_NAME_NORMAL_SCALE );
		}
		m_pShaderVarNormalScale->SetVector2( m_fNormalScaleU, m_fNormalScaleV );
	}
	else
	{
		if ( m_pShaderVarNormalScale ) delete m_pShaderVarNormalScale;
		m_pShaderVarNormalScale = 0;
	}

	// set up lights
	if ( m_iNumVSLights > 0 || m_iNumPSLights > 0 )
	{
		uint32_t maxLights = m_iNumVSLights;
		if ( m_iNumPSLights > maxLights ) maxLights = m_iNumPSLights;
		float *lightPos = new float[ maxLights*4 ];
		float *lightColor = new float[ maxLights*4 ];
		
		if ( m_iNumVSLights )
		{
			for ( uint32_t i = 0; i < m_iNumVSLights; i++ )
			{
				lightPos[ i*4 + 0 ] = m_pVSLights[i]->m_position.x;
				lightPos[ i*4 + 1 ] = m_pVSLights[i]->m_position.y;
				lightPos[ i*4 + 2 ] = m_pVSLights[i]->m_position.z;
				lightPos[ i*4 + 3 ] = m_pVSLights[i]->m_fRadius * m_pVSLights[i]->m_fRadius;

				lightColor[ i*4 + 0 ] = m_pVSLights[i]->m_color.x;
				lightColor[ i*4 + 1 ] = m_pVSLights[i]->m_color.y;
				lightColor[ i*4 + 2 ] = m_pVSLights[i]->m_color.z;
				lightColor[ i*4 + 3 ] = 0;
			}

			if ( !m_pShaderVarVSLightPos ) 
			{
				m_pShaderVarVSLightPos = new AGKShaderConstantArray();
				m_pShaderVarVSLightPos->SetKnownName( AGK_SHADER_CONSTANT_NAME_VS_LIGHT_POS );
			}
			m_pShaderVarVSLightPos->SetArrayVector( lightPos, m_iNumVSLights, AGK_SHADER_CONSTANT_TYPE_VEC4 );

			if ( !m_pShaderVarVSLightColor ) 
			{
				m_pShaderVarVSLightColor = new AGKShaderConstantArray();
				m_pShaderVarVSLightColor->SetKnownName( AGK_SHADER_CONSTANT_NAME_VS_LIGHT_COLOR );
			}
			m_pShaderVarVSLightColor->SetArrayVector( lightColor, m_iNumVSLights, AGK_SHADER_CONSTANT_TYPE_VEC4 );
		}
		else
		{
			if ( m_pShaderVarVSLightPos ) delete m_pShaderVarVSLightPos;
			if ( m_pShaderVarVSLightColor ) delete m_pShaderVarVSLightColor;

			m_pShaderVarVSLightPos = 0;
			m_pShaderVarVSLightColor = 0;
		}

		if ( m_iNumPSLights )
		{
			for ( uint32_t i = 0; i < m_iNumPSLights; i++ )
			{
				lightPos[ i*4 + 0 ] = m_pPSLights[i]->m_position.x;
				lightPos[ i*4 + 1 ] = m_pPSLights[i]->m_position.y;
				lightPos[ i*4 + 2 ] = m_pPSLights[i]->m_position.z;
				lightPos[ i*4 + 3 ] = m_pPSLights[i]->m_fRadius * m_pPSLights[i]->m_fRadius;

				lightColor[ i*4 + 0 ] = m_pPSLights[i]->m_color.x;
				lightColor[ i*4 + 1 ] = m_pPSLights[i]->m_color.y;
				lightColor[ i*4 + 2 ] = m_pPSLights[i]->m_color.z;
				lightColor[ i*4 + 3 ] = 0;
			}
						
			if ( !m_pShaderVarPSLightPos ) 
			{
				m_pShaderVarPSLightPos = new AGKShaderConstantArray();
				m_pShaderVarPSLightPos->SetKnownName( AGK_SHADER_CONSTANT_NAME_PS_LIGHT_POS );
			}
			m_pShaderVarPSLightPos->SetArrayVector( lightPos, m_iNumPSLights, AGK_SHADER_CONSTANT_TYPE_VEC4 );

			if ( !m_pShaderVarPSLightColor ) 
			{
				m_pShaderVarPSLightColor = new AGKShaderConstantArray();
				m_pShaderVarPSLightColor->SetKnownName( AGK_SHADER_CONSTANT_NAME_PS_LIGHT_COLOR );
			}
			m_pShaderVarPSLightColor->SetArrayVector( lightColor, m_iNumPSLights, AGK_SHADER_CONSTANT_TYPE_VEC4 );
		}
		else
		{
			if ( m_pShaderVarPSLightPos ) delete m_pShaderVarPSLightPos;
			if ( m_pShaderVarPSLightColor ) delete m_pShaderVarPSLightColor;

			m_pShaderVarPSLightPos = 0;
			m_pShaderVarPSLightColor = 0;
		}

		delete [] lightColor;
		delete [] lightPos;
	}

	m_shaderConstants.Clear();
	if ( m_pShaderVarNormalScale ) m_shaderConstants.AddItem( m_pShaderVarNormalScale );
	if ( m_pShaderVarVSLightPos ) m_shaderConstants.AddItem( m_pShaderVarVSLightPos );
	if ( m_pShaderVarVSLightColor ) m_shaderConstants.AddItem( m_pShaderVarVSLightColor );
	if ( m_pShaderVarPSLightPos ) m_shaderConstants.AddItem( m_pShaderVarPSLightPos );
	if ( m_pShaderVarPSLightColor ) m_shaderConstants.AddItem( m_pShaderVarPSLightColor );

	if ( m_iFlags & AGK_MESH_UV_SCALES_UPDATED ) UpdateUVOffsetScaleShaderVars();

	for( int i = 0; i <= m_shaderVarUVOffsetScales.GetHighestIndex(); i++ )
	{
		AGKShaderConstantValue *pItem = m_shaderVarUVOffsetScales.GetItem( i );
		if ( pItem ) m_shaderConstants.AddItem( pItem );
	}
	
	Renderer *pRenderer = agk::GetRenderer();

	void **pVertices = m_pInternalVertices;
	int numVertexArrays = m_iNumInternalVertices;
	if ( m_pSharedVertices )
	{
		pVertices = m_pSharedVertices->m_pInternalVertices;
		numVertexArrays = m_pSharedVertices->m_iNumInternalVertices;
	}

	pRenderer->BindPipeline( 0, m_pShader, m_pObject->GetRenderState(), &m_vertexLayout, &m_pInternalPipeline ); 
	pRenderer->BindShaderConstants( 0, m_pShader, &m_shaderConstants, m_pObject->GetShaderConstants(), &m_shaderImages, &m_pInternalConstants );

	for( int i = 0; i < numVertexArrays; i++ ) pRenderer->DrawVertices( 0, pVertices[i] );
}

void cMesh::DrawShadow()
{
	if ( !m_pObject->DoesCastShadows() || !DoesCastShadows() ) return;
	if ( m_pObject->DoesCullToScreen() && !GetInShadowFrustum() ) return;

	AGKShader *pShadowShader = AGKShader::GetShadowShader( HasValidBones() ? GetNumBones() : 0, m_pObject->HasAlphaMask() ? 1 : 0 );
	if ( pShadowShader != m_pShadowShader )
	{
		if ( !m_pSharedVertices ) UpdateVertexLayout( &m_shadowVertexLayout, pShadowShader );
		else m_pSharedVertices->UpdateVertexLayout( &m_shadowVertexLayout, pShadowShader );
		m_pShadowShader = pShadowShader;
	}

	void **pVertices = m_pInternalVertices;
	int numVertexArrays = m_iNumInternalVertices;
	if ( m_pSharedVertices )
	{
		pVertices = m_pSharedVertices->m_pInternalVertices;
		numVertexArrays = m_pSharedVertices->m_iNumInternalVertices;
	}

	Renderer *pRenderer = agk::GetRenderer();
	pRenderer->BindPipeline( 0, m_pShadowShader, &g_shadowRenderState, &m_shadowVertexLayout, &m_pInternalShadowPipeline );

	if ( m_pObject->HasAlphaMask() && m_shaderImages.GetItem(0) )
	{
		if ( m_iFlags & AGK_MESH_UV_SCALES_UPDATED ) UpdateUVOffsetScaleShaderVars();

		AGKUnorderedArray<AGKShaderConstantValue*> shadowVariables(1);
		AGKShaderConstantValue *pUVScale0 = m_shaderVarUVOffsetScales.GetItem( 0 );
		if ( pUVScale0 ) shadowVariables.AddItem( pUVScale0 );

		AGKDynamicArray<cImage*> shadowImages(1);
		shadowImages.SetItem( 0, m_shaderImages.GetItem(0) );
		
		pRenderer->BindShaderConstants( 0, m_pShadowShader, &shadowVariables, m_pObject->GetShaderShadowConstants(), &shadowImages, &m_pInternalShadowConstants );
	}
	else 
	{
		pRenderer->BindShaderConstants( 0, m_pShadowShader, m_pObject->GetShaderShadowConstants(), 0, 0, &m_pInternalShadowConstants );
	}

	for( int i = 0; i < numVertexArrays; i++ ) pRenderer->DrawVertices( 0, pVertices[i] );
}
